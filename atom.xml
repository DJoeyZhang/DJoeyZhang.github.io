<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>权译&#39;s  Blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DJoeyZhang/"/>
  <updated>2020-10-12T07:58:03.430Z</updated>
  <id>https://github.com/DJoeyZhang/</id>
  
  <author>
    <name>权译</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库相关记录</title>
    <link href="https://github.com/DJoeyZhang/archives/76c48a64.html"/>
    <id>https://github.com/DJoeyZhang/archives/76c48a64.html</id>
    <published>2020-10-12T07:57:11.000Z</published>
    <updated>2020-10-12T07:58:03.430Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些数据库相关<br><a id="more"></a></p><p>1、使用sequel pro操作数据库<br><br><a href="https://blog.csdn.net/zs_pnzzz/article/details/79769146" target="_blank" rel="noopener">https://blog.csdn.net/zs_pnzzz/article/details/79769146</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些数据库相关&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>apktool command</title>
    <link href="https://github.com/DJoeyZhang/archives/bb48e990.html"/>
    <id>https://github.com/DJoeyZhang/archives/bb48e990.html</id>
    <published>2020-10-10T08:52:59.000Z</published>
    <updated>2020-10-10T08:54:21.759Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些apktool使用<br><a id="more"></a></p><p>1、apktool d my.apk 无权限时：chmod a+x *.sh<br><br>2、dex2jar后用JD_GUI打开报路径错误时：sudo chmod +xr</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些apktool使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些前端面试题</title>
    <link href="https://github.com/DJoeyZhang/archives/706e1d98.html"/>
    <id>https://github.com/DJoeyZhang/archives/706e1d98.html</id>
    <published>2020-09-14T07:55:10.000Z</published>
    <updated>2020-09-14T08:01:43.186Z</updated>
    
    <content type="html"><![CDATA[<p>preface：<br><br>应朋友邀请，去新公司做前端负责人。公司目前前端工作内容主要是后台管理界面。一些老的项目是vue开发维护的。技术栈主要在vue-admin和react-admin。<br><br>记录整理的一些面试题，着重考察候选人前端基础和框架的熟悉程度，提升考察候选人对框架的理解和一些发散思维。<br><a id="more"></a></p><h5 id="考察范围："><a href="#考察范围：" class="headerlink" title="考察范围："></a>考察范围：<br></h5><h6 id="一、JS基础考察："><a href="#一、JS基础考察：" class="headerlink" title="一、JS基础考察："></a>一、JS基础考察：<br></h6><p>1、闭包和作用域,箭头函数中的this。<br><br>2、深浅拷贝的区别。<br><br>3、http\https\websocket区别和使用场景，常用的请求方法及状态码。<br><br>4、浏览器缓存。强缓存和协商缓存区别。<br></p><h6 id="二、Vue基础考察"><a href="#二、Vue基础考察" class="headerlink" title="二、Vue基础考察:"></a>二、Vue基础考察:<br></h6><p>1、组件生命周期？哪个钩子函数中可以拿到Dom节点, 在created还是mounted？<br><br>2、父子组件通信，事件和属性的传递模式。<br><br>3、MVC \ MVVM 的理解？Vue借鉴了哪种模式？双向绑定的数据，变量污染如何排查。<br><br>4、数据驱动父组件重绘时，部分子组件不想重绘，如何做? (keep=alive) <br></p><h6 id="三、React基础考察"><a href="#三、React基础考察" class="headerlink" title="三、React基础考察:"></a>三、React基础考察:<br></h6><p>1、组件key的作用。<br><br>2、lodash 防抖和节流。<br><br>3、组件生命周期，网络请求通常写在哪个钩子上？虚拟DOM 的diff算法处理，shouldupdate回调时机，顺便问问渲染性能优化。<br><br>5、vuex和Redux的设计和作用。<br></p><h6 id="四、针对简历项目提问考察"><a href="#四、针对简历项目提问考察" class="headerlink" title="四、针对简历项目提问考察"></a>四、针对简历项目提问考察<br></h6><h6 id="五、发散思维考察："><a href="#五、发散思维考察：" class="headerlink" title="五、发散思维考察："></a>五、发散思维考察：<br></h6><p>1、JQ和vue\react比较，JQ有哪些缺陷。<br><br>2、从浏览器地址栏输入url到页面加载渲染出来，都发生了什么。<br><br>3、职业规划。期望薪资。<br></p><h5 id="六、评价维度："><a href="#六、评价维度：" class="headerlink" title="六、评价维度："></a>六、评价维度：<br></h5><p>1、基础知识<br><br>2、框架熟悉度<br><br>3、语言表达、协作沟通能力<br><br>4、可塑性（学习意愿）<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;preface：&lt;br&gt;&lt;br&gt;应朋友邀请，去新公司做前端负责人。公司目前前端工作内容主要是后台管理界面。一些老的项目是vue开发维护的。技术栈主要在vue-admin和react-admin。&lt;br&gt;&lt;br&gt;记录整理的一些面试题，着重考察候选人前端基础和框架的熟悉程度，提升考察候选人对框架的理解和一些发散思维。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Flutter的一些脚手架和不错的博文（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/f67afe4b.html"/>
    <id>https://github.com/DJoeyZhang/archives/f67afe4b.html</id>
    <published>2020-09-08T08:28:33.000Z</published>
    <updated>2020-09-08T08:29:50.998Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用flutter重构来话应用。期间参考的一些不错的资料，记录下来。<br><a id="more"></a><br>1、flutter轮子大全：<br><a href="https://pub.dev/flutter/packages" target="_blank" rel="noopener">https://pub.dev/flutter/packages</a></p><p>2、关于flutter的布局讲解：<br><a href="https://www.cnblogs.com/lxlx1798/p/11084904.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxlx1798/p/11084904.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用flutter重构来话应用。期间参考的一些不错的资料，记录下来。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>来话应用Flutter重构可研</title>
    <link href="https://github.com/DJoeyZhang/archives/61fe53de.html"/>
    <id>https://github.com/DJoeyZhang/archives/61fe53de.html</id>
    <published>2020-08-31T01:00:27.000Z</published>
    <updated>2020-08-31T05:37:06.341Z</updated>
    
    <content type="html"><![CDATA[<p>目标和资源：<br><br>    来话应用一期Android端上线后，希望以flutter重构业务逻辑，实现ADR/IOS双端上线。 <br><br>   目前组内可供开发人力，Android 3人，IOS/MACOS 2人。<br><a id="more"></a></p><h5 id="一、工作拆解："><a href="#一、工作拆解：" class="headerlink" title="一、工作拆解："></a>一、工作拆解：</h5><h6 id="1、架构设计："><a href="#1、架构设计：" class="headerlink" title="1、架构设计："></a>1、架构设计：</h6><p>来话Android端架构设计：<br><br>模块化解耦合，抽取module_base,module_function,module_user,app四个模块，其中module_base承载应用的基类和MVVM框架设计，module_function和module_user承载产品的具体功能函数和用户的信息管理，app模块是整个应用的壳工程，用来对接一些三方SDK。工程采用了jetbrain anko,okhttp3/retrofit/rxjava/dagger2/glide等一系列流行框架作为脚手架。<br></p><p>来话Flutter端架构设计：<br><br>总体设计上可复用来话Android端架构。工具框架参考flutter开发者社区，大体覆盖了我方功能需求。但flutter所选框架在Adr/IOs双端的兼容性需要双端工程师进行调试。</p><h6 id="2、Tencent-IM-SDK-SensorSDK-TingYun-SDK-XGPush的桥接（工作量大，重难点）"><a href="#2、Tencent-IM-SDK-SensorSDK-TingYun-SDK-XGPush的桥接（工作量大，重难点）" class="headerlink" title="2、Tencent IM SDK / SensorSDK / TingYun SDK / XGPush的桥接（工作量大，重难点）"></a>2、Tencent IM SDK / SensorSDK / TingYun SDK / XGPush的桥接（工作量大，重难点）</h6><p>以上四者SDK，分别提供了来话的 即时通话能力 、 商化统计能力 、 性能监控能力 、推送及接收消息能力。且此四者SDK并无Flutter版本，需要双端工程师根据SDK的开放API，选定合适版本进行桥接编写。</p><h6 id="3、工具类封装、基类编写："><a href="#3、工具类封装、基类编写：" class="headerlink" title="3、工具类封装、基类编写："></a>3、工具类封装、基类编写：</h6><p>此工作采用Dart,由Adr工程师编写，IOS端工程师负责单侧调试。</p><h6 id="4、功能页面的编写：（工作量大-且琐碎）"><a href="#4、功能页面的编写：（工作量大-且琐碎）" class="headerlink" title="4、功能页面的编写：（工作量大,且琐碎）"></a>4、功能页面的编写：（工作量大,且琐碎）</h6><p>此工作采用Dart,由Adr工程师编写，IOS端工程师负责单侧调试。</p><h6 id="5、权限功能编写："><a href="#5、权限功能编写：" class="headerlink" title="5、权限功能编写："></a>5、权限功能编写：</h6><p>来话产品所需求（eg:静默下载，本地通讯录联系人等）的一系列敏感权限，IOS工程师需评估其对于上架审核有无影响。部分诸如强制更新，后台唤起等功能IOS端恐怕实现困难，需寻找替代方案。</p><h5 id="二、风险评估："><a href="#二、风险评估：" class="headerlink" title="二、风险评估："></a>二、风险评估：</h5><h6 id="1、-开发人员技术栈现状："><a href="#1、-开发人员技术栈现状：" class="headerlink" title="1、 开发人员技术栈现状："></a>1、 开发人员技术栈现状：</h6><p>有flutter开发经验的Android工程师仅1人。其余四人需要培训学习后兼顾进行开发，人力投入上难以 all in。</p><h6 id="2、-应用权限申请："><a href="#2、-应用权限申请：" class="headerlink" title="2、 应用权限申请："></a>2、 应用权限申请：</h6><p>来话Android端申请了许多诸如：通讯录读取、静默下载、浮动在上层应用等敏感权限。IOS端恐怕无法申请并过审。</p><h5 id="三、开发、协作模式："><a href="#三、开发、协作模式：" class="headerlink" title="三、开发、协作模式："></a>三、开发、协作模式：</h5><p>人力现状：<br>Android工程师充足，但手中有其他工作；IOS工程师人力少，手中有其他工作且处于异地。</p><h6 id="建议的协作开发模式："><a href="#建议的协作开发模式：" class="headerlink" title="建议的协作开发模式："></a>建议的协作开发模式：</h6><p>1、Android端先行进入调研开发。工作优先级：SDK的桥接封装协议制定及编码 &gt; 框架设计、基类、工具编写 &gt; 具体功能界面编写实现。</p><p>2、IOS端待SDK封装协议制定后进入开发。根据Android端开发进度进行适配(android端需制定短期里程碑计划，定期输出flutter编码供IOS端适配调试)。</p><h5 id="四、工期评估："><a href="#四、工期评估：" class="headerlink" title="四、工期评估："></a>四、工期评估：</h5><h6 id="1、SDK封装协议及编码开发：-—-共计：30人日"><a href="#1、SDK封装协议及编码开发：-—-共计：30人日" class="headerlink" title="1、SDK封装协议及编码开发： —-共计：30人日"></a>1、SDK封装协议及编码开发： —-共计：30人日</h6><pre><code>Tencent IM SDK 桥接协议制定编写。----7人日SensorSDK 桥接协议制定编写。----7人日TingYun SDK 桥接协议制定编写。----7人日XGPush SDK 桥接协议制定编写。----7人日调试自测。 ----2人日</code></pre><h6 id="2、架构设计、框架开发：-—-共计：6人日"><a href="#2、架构设计、框架开发：-—-共计：6人日" class="headerlink" title="2、架构设计、框架开发： —-共计：6人日"></a>2、架构设计、框架开发： —-共计：6人日</h6><pre><code>工程架构搭建。----2人日依赖管理。----2人日调试自测。 ----2人日</code></pre><h6 id="3、功能页面编写：-—-共计：45人日"><a href="#3、功能页面编写：-—-共计：45人日" class="headerlink" title="3、功能页面编写： —- 共计：45人日"></a>3、功能页面编写： —- 共计：45人日</h6><pre><code>首页通话记录模块。----2人日首页通讯录模块。 ----2人日首页设置模块。----1人日消息模块。----2人日预约功能模块。 ---- 3人日多选联系人功能模块。 ----3人日设置模块、关于模块、扫一扫添加联系人模块。----3人日添加联系人、通讯录校验、好友邀请模块。----4人日下载升级功能。 ----3人日单人、多人通话功能。 ----14人日登陆注册模块。----2人日所有模块埋点统计。----2人日调试自测。 ----4人日</code></pre><h6 id="4、基类、工具类编写：-—-共计：5人日"><a href="#4、基类、工具类编写：-—-共计：5人日" class="headerlink" title="4、基类、工具类编写： —-共计：5人日"></a>4、基类、工具类编写： —-共计：5人日</h6><h6 id="5、权限体系编写：-—-6人日"><a href="#5、权限体系编写：-—-6人日" class="headerlink" title="5、权限体系编写： —-6人日"></a>5、权限体系编写： —-6人日</h6><p>共计：92人日。（预估前提：在重构工作无产品干预的前提下，仅以我个人开发能力all in状态进行Android端flutter重构的乐观评估。IOS侧适配工期需IOS工程师另行评估）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目标和资源：&lt;br&gt;&lt;br&gt;    来话应用一期Android端上线后，希望以flutter重构业务逻辑，实现ADR/IOS双端上线。 &lt;br&gt;&lt;br&gt;   目前组内可供开发人力，Android 3人，IOS/MACOS 2人。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一些好用的配置工具和lint配置</title>
    <link href="https://github.com/DJoeyZhang/archives/70f14e75.html"/>
    <id>https://github.com/DJoeyZhang/archives/70f14e75.html</id>
    <published>2020-08-28T00:56:54.000Z</published>
    <updated>2020-08-28T00:58:15.200Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。<br><a id="more"></a></p><p>1、 cc 开发eslint 配置<br><br><a href="https://www.dazhuanlan.com/2020/01/06/5e12ae47f1581/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/06/5e12ae47f1581/</a></p><p>2、MacBook brew update 慢的问题。<br><a href="https://www.jianshu.com/p/edfe9af41117" target="_blank" rel="noopener">https://www.jianshu.com/p/edfe9af41117</a></p><p>3、在mac终端先cd对应目录，然后执行以下命令，目录下会多了一些jpg格式的图片。<br>for i in .CR2; do sips -s format jpeg $i –out “${i%.}.jpg”; done</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一起来找茬开发手记。cocos creator探索之路</title>
    <link href="https://github.com/DJoeyZhang/archives/8434bd43.html"/>
    <id>https://github.com/DJoeyZhang/archives/8434bd43.html</id>
    <published>2020-08-20T16:10:53.000Z</published>
    <updated>2020-08-25T02:19:58.835Z</updated>
    
    <content type="html"><![CDATA[<p>要睡了,先随便记点，有空再整理。<br><a id="more"></a></p><p>0、关于上次讨论热区配置问题：解决方案如上图<br>    设图片width，height均为1.<br>    左上角建立坐标系，x1,x2,y1,y2分别为x轴坐标/width，y轴坐标/height的比例值。<br>    x1,x2,y1,y2 in (0,1)</p><pre><code>给出配置文件数据结构形如：{url:&quot;www.picture.com&quot;,hotArea:[    {x1:0.5,x2:0.75,y1:0.25,y2:0.5},    ...]如此运营每次设置好热区后，只需要计算一下这四个数就可以了，比切九宫格简单。配置像素值不可取，因图片在前端展示可能会压缩，且按照dip、pt或者rem适配，在不同设备上，px值应该不一样。</code></pre><p>}</p><p>1、关于前端技术选型：</p><pre><code>抖音小游戏支持的主流2种引擎：Cocos Creator,Egret白鹭其中egret引擎文档已经上次更新已经是16年。抛弃。经技术社区调研，CC具备以下优点：version 2.4.2 support了字节小游戏以及字节小游戏开放域的构建发布。引擎侵入性很小，可在字节开发者工具中进行产物二次开发。ES6/7语法，JS栈亲和。API覆盖全面，文档详细。综上，前端决定选用CC引擎。</code></pre><p>2、关于游戏服务端调研：</p><pre><code>浏览多个技术社区和逼乎专栏，多数推荐网易LeanCloud作为游戏服务的后端支持。LeanCloud提供了详细的多人在线游戏server解决方案。部署和运维看起来也挺方便的。收费看着也还行，官网丢出来供服务端大佬参考：https://leancloud.cn/docs/multiplayer-server.html#hash1086233181</code></pre><p>3、Cocos Creator .gitIgnore config<br><a href="https://blog.csdn.net/themagickeyjianan/article/details/82901189" target="_blank" rel="noopener">https://blog.csdn.net/themagickeyjianan/article/details/82901189</a></p><p>4、坑。8月23日进开发，因产品设计较多的路由页面，突发奇想用小程序模版开发。结果25日发现小程序中调用不到小游戏的API，并且发布也归类不到小游戏，唉，重头再来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要睡了,先随便记点，有空再整理。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杂项(记一些遇到的问题)</title>
    <link href="https://github.com/DJoeyZhang/archives/a96b87af.html"/>
    <id>https://github.com/DJoeyZhang/archives/a96b87af.html</id>
    <published>2020-08-20T15:30:37.000Z</published>
    <updated>2020-08-28T00:58:24.131Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一些工作遇到的问题，和平时的一些思考。<br><a id="more"></a><br>1、MacBook brew update 慢的问题。<br><a href="https://www.jianshu.com/p/edfe9af41117" target="_blank" rel="noopener">https://www.jianshu.com/p/edfe9af41117</a></p><p>2、在mac终端先cd对应目录，然后执行以下命令，目录下会多了一些jpg格式的图片。<br>for i in <em>.CR2; do sips -s format jpeg $i –out “${i%.</em>}.jpg”; done</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一些工作遇到的问题，和平时的一些思考。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin开发编码规范</title>
    <link href="https://github.com/DJoeyZhang/archives/10213c17.html"/>
    <id>https://github.com/DJoeyZhang/archives/10213c17.html</id>
    <published>2020-07-28T02:00:04.000Z</published>
    <updated>2020-07-28T03:41:49.657Z</updated>
    
    <content type="html"><![CDATA[<p></p><h4>Preface:</h4><br>众所周知，Android团队已经接纳Kotlin为其平台性开发语言，可以预见将来会有越来越多的Android项目用Kotlin写成。随着Kotlin被引入到不同的开发团队，与其相关的代码规范也会越来越受关注。<br><a id="more"></a><br>以下是我查找多方资料初步整理的kotlin编码规范，如有不妥，敬请斧正。<p></p><p></p><h5>命名格式</h5><br>总体来说，Kotlin命名格式要和Java命名规范保持一致，因为Kotlin也是JVM兼容的语言。<p></p><p></p><h5>包名</h5><br>包的命名规则和Java一样：全小写，当遇到多个词连接的场景，不要使用下划线(_)和连字号(-)。<p></p><p><b>推荐</b><br><br>package vn.asiantech.android<br><br><b>不推荐</b><br><br>package Vn.Asiantech.Android</p><p></p><h5>类和接口</h5><br>命名遵守大驼峰规则（首字母大写）。<p></p><p><b>推荐</b><br><br>HomeActivity<br><br>MainFragment<br></p><p></p><h5>方法</h5><br>命名遵守小驼峰规则（首字母小写）。<p></p><p><b>推荐</b><br><br>setData<br><br>getApiNews</p><p></p><h5>字段（Fields）</h5><br>总体来说，字段命名遵守小驼峰规则，不建议使用匈牙利法。<p></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  var publicField: Int = 0</span><br><span class="line">  val person = Person()</span><br><span class="line">  private var privateField: Int?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而伴生对象中的常量定义要遵守规则：全大写，单词连接使用下划线。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">  const val THE_ANSWER = 42</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变量和参数"><a href="#变量和参数" class="headerlink" title="变量和参数"></a>变量和参数</h5><p>一句话概括： 小驼峰命名法。<br><br>不建议使用单个字符的变量，除非是循环中的临时变量。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>首字母缩略词作为完整单词看待，适时选择命名规则。</p><p><b>推荐</b><br><br>XMLHTTPRequest<br><br>URL: String? <br><br>findPostByID<br><br><b>不推荐</b><br><br>XmlHttpRequest<br><br>url: String<br><br>findPostById<br></p><h5 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h5><p><b>缩进</b><br><br>缩进使用4个空格，不建议使用tabs - 制表符。</p><p><b>闭包</b><br><br>闭包的缩进使用2个空格，</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">  Log.i(TAG, &quot;index=&quot; + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">    Log.i(TAG, &quot;index=&quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h5><p>新的换行缩进使用4个空格，而不是默认的8个。</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val widget: CoolUiWidget =</span><br><span class="line">    someIncrediblyLongExpression(that, reallyWouldNotFit, on, aSingle, line)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val widget: CoolUiWidget =</span><br><span class="line">        someIncrediblyLongExpression(that, reallyWouldNotFit, on, aSingle, line)</span><br></pre></td></tr></table></figure></p><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>每行不应超过130个字符，这在Android Studio内可以配置。<br><br>如果单行代码超过限制需要换行显示，使用, / : / { , = 作为首行的结尾。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun setData(name: String, age: Int, class: String, date: String, message: String,</span><br><span class="line">     time: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun getInfo(name: String, birth: String, age: Int, weight: Float, hight: Float) =</span><br><span class="line">   getInfo().apply &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data class Animal(private val weight: Float, private val hight: Float) :</span><br><span class="line">         AbstractAnimal() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="垂直间距"><a href="#垂直间距" class="headerlink" title="垂直间距"></a>垂直间距</h5><p>方法体之间保留一个空行，这样可以让结构清晰。<br><br>方法体内的空行用来分割不同功能，这样如果一个方法内分多个部分，也许需要重构代码了。<br></p><h5 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h5><p>类型和父类型之间的冒号前面要保留空格，而变量和类型之间的冒号前没有空格。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Foo&lt;out T : Any&gt; : Bar &#123;</span><br><span class="line">    fun foo(a: Int): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 申明变量类型</span><br><span class="line"></span><br><span class="line">val firstName: String</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Foo&lt;out T:Any&gt;: Bar &#123;</span><br><span class="line">    fun foo(a : Int):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 申明变量类型</span><br><span class="line"></span><br><span class="line">val firstName:String</span><br></pre></td></tr></table></figure></p><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>在定义类的时候，在结构体的右括号和类主题的左括号之间保留空格，结构体的每个参数单行显示。<br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(</span><br><span class="line">    public open var firstName: String,</span><br><span class="line">    public open var lastName: String</span><br><span class="line">) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class User(public open var firstName: String, public open var lastName: String)&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在定义子类或实现接口的时候，上面提到的规则仍然适用，且冒号和父类名之间要保留空格，冒号和结构体之间不需要空格。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(</span><br><span class="line">    public open var firstName: String,</span><br><span class="line">    public open var lastName: String</span><br><span class="line">): RealmObject() &#123;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="分号（-）"><a href="#分号（-）" class="headerlink" title="分号（;）"></a>分号（;）</h5><p>在Kotlin中避免使用分号。</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val horseGiftedByTrojans = true</span><br><span class="line">if (horseGiftedByTrojans) &#123;</span><br><span class="line">  bringHorseIntoWalledCity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val horseGiftedByTrojans = true;</span><br><span class="line">if (horseGiftedByTrojans) &#123;</span><br><span class="line">  bringHorseIntoWalledCity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="括号格式"><a href="#括号格式" class="headerlink" title="括号格式"></a>括号格式</h5><p>方法体的大括号和其他大括号首括号和前面代码在同一行，尾括号新起一行。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  fun doSomething() &#123;</span><br><span class="line">    if (someTest) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line">  fun doSomething()</span><br><span class="line">  &#123;</span><br><span class="line">    if (someTest)</span><br><span class="line">    &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="括号格式-1"><a href="#括号格式-1" class="headerlink" title="括号格式"></a>括号格式</h5><p>条件判断语句必须内嵌在括号里，无论其是多少行。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (someTest) &#123;</span><br><span class="line">  doSomething()</span><br><span class="line">&#125;</span><br><span class="line">if (someTest) &#123; doSomethingElse() &#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (someTest)</span><br><span class="line">  doSomething()</span><br><span class="line">if (someTest) doSomethingElse()</span><br></pre></td></tr></table></figure></p><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>尽可能使用Kotlin原生类型。</p><h5 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h5><p>避免显式地声明Unit类型，因为不显式声明返回类型的函数都会返回 Unit 类型。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun doSomething()</span><br></pre></td></tr></table></figure></p><p>不推荐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun doSomething(): Unit</span><br></pre></td></tr></table></figure></p><h5 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h5><p>优先使用类型推导。（对编译速度有少许影响？）<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val something = MyType()</span><br><span class="line">val meaningOfLife = 42</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val something: MyType = MyType()</span><br><span class="line">val meaningOfLife: Int = 42</span><br></pre></td></tr></table></figure></p><h5 id="常量-vs-变量"><a href="#常量-vs-变量" class="headerlink" title="常量 vs 变量"></a>常量 vs 变量</h5><p>定义常量时使用关键词val， 定义变量时使用关键词var。<br><br>建议： 把所有的值使用val定义，且只在编译器警告的时候修订为var。</p><h5 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h5><p>伴生对象应定义在类文件的上面，而关于伴生对象的命名规范要遵守Java标准规范。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MainFragment: Fragment() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val TYPE_VIEW_HEADER = 0</span><br><span class="line">        const val TYPE_VIEW_FOOTER = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MainFragment: Fragment() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val TypeViewHeader = 0</span><br><span class="line">        val TypeViewFooter = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>推荐使用字符串插值语法糖。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val fullName = &quot;$&#123;user.firstName&#125; $&#123;user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val fullName = user.firstName + &quot; &quot; + user.lastName</span><br></pre></td></tr></table></figure></p><h5 id="选配型（-）"><a href="#选配型（-）" class="headerlink" title="选配型（?）"></a>选配型（?）</h5><p>变量和方法返回可以声明为选配型，这种情况赋值null也是允许的。<br></p><p>使用隐式拆包!!时候要小心，只能在确认实例对象在被使用前已经初始化，如在Activity方法onCreate使用的子视图。<br></p><p>在为选配型变量和参数命名的时候，不用使用类maybeView 和 optionalString的名称，因为选配类型已经表明了这一点。<br></p><p>在访问选配型变量值时，可使用可选链（Optional Chaining）。<br></p><p><b>eg:editText?.setText(“foo”)</b></p><h5 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h5><p>使用IDE提示<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val array = ArrayList&lt;Int&gt;()</span><br><span class="line">array[0]</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">activity().finish()</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val array = ArrayList&lt;Int&gt;()</span><br><span class="line">array.get(0)</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">getActivity().finish()</span><br></pre></td></tr></table></figure></p><p>it 在 Lambda 语句中适应较广范围。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  it?.let &#123; animal -&gt; animal.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal -&gt; </span><br><span class="line">  animal?.let &#123; it.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用类型推断，除非是难以理解的时候。"><a href="#使用类型推断，除非是难以理解的时候。" class="headerlink" title="使用类型推断，除非是难以理解的时候。"></a>使用类型推断，除非是难以理解的时候。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//属性</span><br><span class="line">val age = 0       // Int</span><br><span class="line">val foo = 10L     // Long</span><br><span class="line">val height = 100f // Float</span><br><span class="line"></span><br><span class="line">//函数</span><br><span class="line">// return Boolean</span><br><span class="line">fun Context.isConnectToWifi() =</span><br><span class="line">      (getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager)</span><br><span class="line">         .activeNetworkInfo?.type == ConnectivityManager.TYPE_WIFI</span><br><span class="line"></span><br><span class="line">// return Point</span><br><span class="line">fun Display.getSize(): Point = Point().apply &#123; getSize(this) &#125;</span><br></pre></td></tr></table></figure></p><h5 id="不要显式地写for循环。"><a href="#不要显式地写for循环。" class="headerlink" title="不要显式地写for循环。"></a>不要显式地写for循环。</h5><p>Kotlin中集合的支持forEach遍历。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0..9).forEach &#123;</span><br><span class="line">// todo somethings</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(0..9).forEachIndexed &#123; index, value -&gt;</span><br><span class="line">// todo somethings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">  // todo somethings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-to-快速创建Pair类的实例。"><a href="#使用-to-快速创建Pair类的实例。" class="headerlink" title="使用 to 快速创建Pair类的实例。"></a>使用 to 快速创建Pair类的实例。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val pair = Pair(foo, bar)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val pair = foo to bar</span><br></pre></td></tr></table></figure></p><h5 id="使用优雅的类型转换。"><a href="#使用优雅的类型转换。" class="headerlink" title="使用优雅的类型转换。"></a>使用优雅的类型转换。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog as? Animal ?: throw IllegalArgumentException(&quot;not Animal!&quot;)</span><br><span class="line">dog.foo()</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (dog !is Animal) &#123;</span><br><span class="line">    throw IllegalArgumentException(&quot;not Animal!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">dog.foo()</span><br></pre></td></tr></table></figure></p><h5 id="Getters-amp-Setters"><a href="#Getters-amp-Setters" class="headerlink" title="Getters &amp; Setters"></a>Getters &amp; Setters</h5><p> Kotlin中推荐直接访问属性。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// syntax</span><br><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自定义setter</span><br><span class="line">var stringRepresentation: String</span><br><span class="line">    get() = this.toString()</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        setDataFromString(value) // parses the string and assigns values to other properties</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="When语句"><a href="#When语句" class="headerlink" title="When语句"></a>When语句</h5><p>Kotlin的When语句和Java中的Switch有稍许区别，如不会fall through。如果不同的case具有相同的处理策略，使用逗号（,）,并且else语句是必须的。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when (anInput) &#123;</span><br><span class="line">  1, 2 -&gt; doSomethingForCaseOneOrTwo()</span><br><span class="line">  3 -&gt; doSomethingForCaseThree()</span><br><span class="line">  else -&gt; println(&quot;No case satisfied&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when (anInput) &#123;</span><br><span class="line">  1 -&gt; doSomethingForCaseOne()</span><br><span class="line">  2 -&gt; doSomethingForCaseOneOrTwo()</span><br><span class="line">  3 -&gt; doSomethingForCaseThree()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="变量可视性修饰符"><a href="#变量可视性修饰符" class="headerlink" title="变量可视性修饰符"></a>变量可视性修饰符</h5><p>默认修饰符是public，如果没有其他需要可以省略。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val wideOpenProperty = 1</span><br><span class="line">private val myOwnPrivateProperty = &quot;private&quot;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public val wideOpenProperty = 1</span><br><span class="line">private val myOwnPrivateProperty = &quot;private&quot;</span><br></pre></td></tr></table></figure></p><h5 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h5><p>对于每个类，方法和成员变量，访问控制修饰符要显示定义清晰。<br></p><h5 id="变量和字段"><a href="#变量和字段" class="headerlink" title="变量和字段"></a>变量和字段</h5><p>单行一个声明。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username: String</span><br><span class="line">twitterHandle: String</span><br></pre></td></tr></table></figure></p><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>普遍来说，每一个文件定义一个类，对于适合的场合依然可以使用内部类。<br></p><h5 id="Data-类型对象"><a href="#Data-类型对象" class="headerlink" title="Data 类型对象"></a>Data 类型对象</h5><p>对于简单的数据结构，推荐使用data类。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Person(val name: String)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name: String) &#123;</span><br><span class="line">  override fun toString() : String &#123;</span><br><span class="line">    return &quot;Person(name=$name)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>优先使用静态变量，避免使用枚举类，因为内存开销太大。<br><br>如果枚举类没有其他方法，不用换行。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private enum CompassDirection &#123; EAST, NORTH, WEST, SOUTH &#125;</span><br></pre></td></tr></table></figure></p><h5 id="注解（Annotations）"><a href="#注解（Annotations）" class="headerlink" title="注解（Annotations）"></a>注解（Annotations）</h5><p>使用Java式标准注解，特别是override， 关键字要和函数的声明保持同一行。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">  super.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">  super.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Annotations应该在类的上面，-内联如果注解类中的字段"><a href="#Annotations应该在类的上面，-内联如果注解类中的字段" class="headerlink" title="Annotations应该在类的上面， 内联如果注解类中的字段,"></a>Annotations应该在类的上面， 内联如果注解类中的字段,</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Root(strict=false) </span><br><span class="line">public open class User (</span><br><span class="line">    @field:Element public open var firstName: String? = &quot;&quot;,</span><br><span class="line">    @field:Element public open var lastName: String? = &quot;&quot;,</span><br><span class="line">) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Root(strict=false) public open class User (</span><br><span class="line">    @field:Element </span><br><span class="line">    public open var firstName: String? = &quot;&quot;,</span><br><span class="line">    @field:Element </span><br><span class="line">    public open var lastName: String? = &quot;&quot;,</span><br><span class="line">) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>XML文件命名<br><br>文件名要以展示视图的类型作为前缀。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activity_login.xml</span><br><span class="line">fragment_main_screen.xml</span><br><span class="line">button_rounded_edges.xml</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login.xml</span><br><span class="line">main_screen.xml</span><br><span class="line">rounded_edges_button.xml</span><br></pre></td></tr></table></figure></p><h5 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h5><p>和Java一样， XML文件使用2个字符缩进。<br></p><p>使用上下文相关的XML<br><br>任何时候，XML都要定义在相关的文件内。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Strings =&gt; res/values/strings.xml</span><br><span class="line">Styles =&gt; res/values/styles.xml</span><br><span class="line">Colors =&gt; res/color/colors.xml</span><br><span class="line">Animations =&gt; res/anim/</span><br><span class="line">Drawable =&gt; res/drawable</span><br></pre></td></tr></table></figure><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p>我配置的一个Formatter Config,个人感觉比较好用，如有优化，欢迎PR:<br><br><a href="https://github.com/DJoeyZhang/FormatterSetting.gitt">Formatter传送门</a><br><br>参考资料：<br><br><a href="https://kotlinlang.org/docs/reference/properties.html" target="_blank" rel="noopener">kotlin官方文档</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h4&gt;Preface:&lt;/h4&gt;&lt;br&gt;众所周知，Android团队已经接纳Kotlin为其平台性开发语言，可以预见将来会有越来越多的Android项目用Kotlin写成。随着Kotlin被引入到不同的开发团队，与其相关的代码规范也会越来越受关注。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Thread.sleep(0)</title>
    <link href="https://github.com/DJoeyZhang/archives/a239bad0.html"/>
    <id>https://github.com/DJoeyZhang/archives/a239bad0.html</id>
    <published>2020-06-10T01:42:03.000Z</published>
    <updated>2020-06-11T06:54:47.185Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？<br></p><h6 id="思考下面这两个问题："><a href="#思考下面这两个问题：" class="headerlink" title="思考下面这两个问题："></a>思考下面这两个问题：<br></h6><p>假设现在是 2020-05-24 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2020-05-24 12:00:01.000 的时候，这个线程会不会被唤醒？<br><br>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。<br><br>既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？<br><br><a id="more"></a><br>我们先回顾一下操作系统原理<br><br>操作系统中，CPU竞争有很多种策略。<br>Unix系统使用的是时间片算法，而Windows则属于抢占式的。在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。<br><br>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。<br><br>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。<br><br>Sleep函数就是告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。<br><br>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。<br><br>与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。<br><br>对于第二个问题，答案是：有，而且区别很明显。Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。<br><br>另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？&lt;br&gt;&lt;/p&gt;
&lt;h6 id=&quot;思考下面这两个问题：&quot;&gt;&lt;a href=&quot;#思考下面这两个问题：&quot; class=&quot;headerlink&quot; title=&quot;思考下面这两个问题：&quot;&gt;&lt;/a&gt;思考下面这两个问题：&lt;br&gt;&lt;/h6&gt;&lt;p&gt;假设现在是 2020-05-24 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2020-05-24 12:00:01.000 的时候，这个线程会不会被唤醒？&lt;br&gt;&lt;br&gt;某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。&lt;br&gt;&lt;br&gt;既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter常用命令行（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/148810a7.html"/>
    <id>https://github.com/DJoeyZhang/archives/148810a7.html</id>
    <published>2020-04-13T02:05:27.000Z</published>
    <updated>2020-04-13T10:14:08.666Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些flutter开发遇到的问题和一些常用的flutter命令行，方便调试。<br><a id="more"></a></p><p>一、<br><br>flutter    列出所有的命令<br><br>flutter help    查看具体命令的帮助信息<br><br>flutter doctor    查看是否还需要安装其它依赖<br><br>flutter doctor -v    查看详细信息<br><br>flutter channel    查看 Flutter SDK 所有分支<br><br>flutter channel stable    切换分支<br><br>flutter upgrade    升级 Flutter SDK（此命令会同时更新 Flutter SDK 和你的 Flutter 项目依赖包）<br><br>flutter packages get    获取项目所有的依赖包（只更新项目依赖包，不包括 Flutter SDK）<br><br>flutter packages upgrade    获取项目所有依赖包的最新版本（只更新项目依赖包，不包括 Flutter SDK）<br><br>flutter analyze    分析项目代码<br><br>flutter build apk    <br><br>flutter build ios    <br></p><p>二、<br><br>查看Flutter版本<br><br>查看当前版本<br><br>flutter  –version<br><br>查看所有版本<br><br>flutter version<br><br>打印所有命令行用法信息 <br><br>flutter  -h或者flutter  –help<br><br>分析项目的Dart代码。<br><br>flutter  analyze<br><br>Flutter构建命令。<br><br>flutter  build<br><br>列表或开关Flutter通道。<br><br>flutter channel<br><br>删除构建/目录。<br><br>flutter  clean<br><br>配置Flutter设置。<br><br>flutter config<br><br>创建一个新的Flutter项目。<br><br>flutter  create<br><br>列出所有连接的设备。 <br><br>flutter  devices<br><br>展示了有关安装工具的信息。<br><br>flutter doctor<br><br>为当前项目运行Flutter驱动程序测试。<br><br>flutter drive<br><br>格式一个或多个Dart文件。<br><br>flutter format<br><br>在Fuchsia上进行热重载。<br><br>flutter  fuchsia_reload<br><br>显示帮助信息的Flutter。<br><br>flutter help<br><br>在附加设备上安装Flutter应用程序。<br><br>flutter install<br><br>显示用于运行Flutter应用程序的日志输出。<br><br> flutter logs<br><br>命令用于管理Flutter包。<br><br>flutter packages<br><br>填充了Flutter工具的二进制工件缓存。<br><br>flutter  precache<br><br>在附加设备上运行你的Flutter应用程序。<br><br>flutter  run<br><br>从一个连接的设备截图。<br><br>flutter screenshot<br><br>停止在附加设备上的Flutter应用。<br><br>flutter stop<br><br>对当前项目的Flutter单元测试。<br><br>flutter test<br><br>开始并停止跟踪运行的Flutter应用程序。<br><br>flutter trace<br><br>升级你的Flutter副本。<br><br>flutter upgrade<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些flutter开发遇到的问题和一些常用的flutter命令行，方便调试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一些工具命令行（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/6f45ff58.html"/>
    <id>https://github.com/DJoeyZhang/archives/6f45ff58.html</id>
    <published>2020-03-26T06:53:48.000Z</published>
    <updated>2020-08-20T03:42:09.026Z</updated>
    
    <content type="html"><![CDATA[<h6 id="一、查看本地keystore文件（前提是有keystore的密码）"><a href="#一、查看本地keystore文件（前提是有keystore的密码）" class="headerlink" title="一、查看本地keystore文件（前提是有keystore的密码）"></a>一、查看本地keystore文件（前提是有keystore的密码）</h6><p>命令：keytool -list -v -keystore 目标文件路径<br></p><h6 id="二、查看三方应用或是系统应用签名"><a href="#二、查看三方应用或是系统应用签名" class="headerlink" title="二、查看三方应用或是系统应用签名"></a>二、查看三方应用或是系统应用签名</h6><p>右键apk解压，目标文件是META-INF文件夹中的CERT.RSA文件，通过命令keytool.exe命令查看证书信息。可以查看签名的MD5、SHA1、SHA256值及签名算法<br><br>命令：keytool -printcert -file 目标文件路径。</p><h6 id="三、内存检查命令"><a href="#三、内存检查命令" class="headerlink" title="三、内存检查命令:"></a>三、内存检查命令:</h6><p>cd /Users/joey/Library/Android/sdk/platform-tools</p><p>./hprof-conv -z /Users/joey/Desktop/memory/memory-20200819T180839.hprof /Users/joey/Desktop/me.hprof</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;一、查看本地keystore文件（前提是有keystore的密码）&quot;&gt;&lt;a href=&quot;#一、查看本地keystore文件（前提是有keystore的密码）&quot; class=&quot;headerlink&quot; title=&quot;一、查看本地keystore文件（前提是有keyst
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一些不错的博文(持续更新)</title>
    <link href="https://github.com/DJoeyZhang/archives/d68ca116.html"/>
    <id>https://github.com/DJoeyZhang/archives/d68ca116.html</id>
    <published>2020-03-07T15:06:00.000Z</published>
    <updated>2020-09-08T08:29:37.541Z</updated>
    
    <content type="html"><![CDATA[<p>博文而强识，温故而知新。这里记录一些平时看到的不错的文章。<br><br><a id="more"></a></p><p>1、关于Android Sqlite操作的文章，介绍的是Google官方的ROOM库，最近正好在做一个通讯录的需求用到。<br><br>Blog:<a href="https://www.jianshu.com/p/72c8efc3ad87" target="_blank" rel="noopener">https://www.jianshu.com/p/72c8efc3ad87</a><br>github:<a href="https://github.com/HoldMyOwn/RoomDemo">https://github.com/HoldMyOwn/RoomDemo</a><br>ROOM官方：<a href="https://developer.android.google.cn/jetpack/androidx/releases/room" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack/androidx/releases/room</a></p><p>2、关于android应用静默升级，差分包前后端部署实现Blog:<a href="https://www.jianshu.com/p/058fd24bb2da" target="_blank" rel="noopener">https://www.jianshu.com/p/058fd24bb2da</a><br>github:<a href="https://github.com/itlwy/AppSmartUpdate">https://github.com/itlwy/AppSmartUpdate</a></p><p>3、关于OKhttp拦截器搭配retrofit使用<br>BLOG:<a href="https://www.jianshu.com/p/62ab11ddacc8" target="_blank" rel="noopener">https://www.jianshu.com/p/62ab11ddacc8</a></p><p>4、关于Room使用多表查询，建立关系型数据库<br><a href="https://www.jianshu.com/p/c7517ea16d1f" target="_blank" rel="noopener">https://www.jianshu.com/p/c7517ea16d1f</a></p><p>5、关于package.json中依赖版本配置:<br><a href="https://www.jianshu.com/p/e5959bf56844" target="_blank" rel="noopener">https://www.jianshu.com/p/e5959bf56844</a></p><p>6、关于HomeBrew源切换<br><a href="https://www.cnblogs.com/tulintao/p/11134877.html" target="_blank" rel="noopener">https://www.cnblogs.com/tulintao/p/11134877.html</a></p><p>7、关于kotlin携程的阐述<br><a href="https://blog.mindorks.com/mastering-kotlin-coroutines-in-android-step-by-step-guide" target="_blank" rel="noopener">https://blog.mindorks.com/mastering-kotlin-coroutines-in-android-step-by-step-guide</a></p><p>8、一个不错的博主，关于后端技术的博文:<br><a href="https://www.cnblogs.com/keeya/category/1255597.html" target="_blank" rel="noopener">https://www.cnblogs.com/keeya/category/1255597.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博文而强识，温故而知新。这里记录一些平时看到的不错的文章。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="tools" scheme="https://github.com/DJoeyZhang/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>adb 常用命令（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/40bc90d3.html"/>
    <id>https://github.com/DJoeyZhang/archives/40bc90d3.html</id>
    <published>2020-02-11T10:00:00.000Z</published>
    <updated>2020-08-20T03:41:41.490Z</updated>
    
    <content type="html"><![CDATA[<h5 id="ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。"><a href="#ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。" class="headerlink" title="ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。"></a>ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。</h5><a id="more"></a><h5 id="1、http-proxy"><a href="#1、http-proxy" class="headerlink" title="1、http_proxy"></a>1、http_proxy</h5><p><b>设置代理：</b></p><p>adb shell settings put global http_proxy 代理IP地址:端口号</p><p>如：</p><p>adb shell settings put global http_proxy 127.0.0.1:8888</p><p><b>移除代理：</b></p><p>adb shell settings delete global http_proxy</p><p>adb shell settings delete global global_http_proxy_host</p><p>adb shell settings delete global global_http_proxy_port</p><p>adb reboot</p><p>但是，adb shell settings delete global http_proxy，再有些没有delete参数的设备上报错？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Invalid command: delete</span><br><span class="line"></span><br><span class="line">usage:  settings [--user NUM] get namespace key</span><br><span class="line"></span><br><span class="line">        settings [--user NUM] put namespace key value</span><br><span class="line"></span><br><span class="line">&apos;namespace&apos; is one of &#123;system, secure, global&#125;, case-insensitive</span><br><span class="line"></span><br><span class="line">If &apos;--user NUM&apos; is not given, the operations are performed on the owner user.</span><br></pre></td></tr></table></figure></p><p>解决方法，sqlite中找到settings.db,在数据库中删除代理信息（需要Root）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 /data/data/com.android.providers.settings/databases/settings.db</span><br><span class="line">sqlite&gt; select * from global;</span><br><span class="line">sqlite&gt; delete from global where name=&quot;global_http_proxy_host&quot;;</span><br><span class="line">sqlite&gt; delete from global where name=&quot;global_http_proxy_port&quot;;</span><br><span class="line">sqlite&gt; delete from global where name=&quot;http_proxy&quot;;</span><br></pre></td></tr></table></figure></p><p>then adb rebbot</p><p><b>也可以使用第三方apk</b><br><br>AndroidProxySetter工具可以帮助我们使用adb命令可以快速进行wifi代理的设置和清除<br>GitHub地址：</p><p><a href="https://github.com/jpkrause/AndroidProxySetter">https://github.com/jpkrause/AndroidProxySetter</a><br>下好apk后，安装到手机</p><p>adb install proxy-setter-debug-0.2.1.apk</p><p>设置代理：</p><p>adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 代理IP地址 -e port 端口号 -e ssid WIFI名称 -e reset-wifi true -e key WIFI密码</p><p>如：</p><p>adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 127.0.0.1 -e port 8888 -e ssid YOUR-WIFI-NAME -e reset-wifi true -e key YOUR-WIFI-PASSWORD</p><h5 id="2、安装、卸载应用"><a href="#2、安装、卸载应用" class="headerlink" title="2、安装、卸载应用"></a>2、安装、卸载应用</h5><p><b>安装：</b><br><br>adb install com.xxx.xxx(包名)<br><br><b>卸载：</b><br><br>adb uninstall com.xxx.xxx(包名)</p><h5 id="3、调试应用"><a href="#3、调试应用" class="headerlink" title="3、调试应用"></a>3、调试应用</h5><p><b>抓日志：</b><br><br>adb logcat -v time &gt; ~\logcat.log<br></p><p><b>列出adb连接的设备:</b><br><br>adb devices</p><p><b>PC机连接某个电视盒子设备:</b><br><br>adb connect 192.168.1.19(连接某个设备，192.168.1.19是设备的IP地址，手机测试一般用不到，盒子或者电视设备会用到)</p><p><b>清除安装的APK缓存数据:</b><br><br>adb shell pm clear com.hiveview.tv（包名） <br><br>清除某个apk缓存数据，清空的是 /data/data/包名/ 下的数据，包括数据库文件等</p><p><b>查看APK包名版本信息:</b><br><br>aapt dump badging pc上apk路径地址<br><br>查看某个apk（在Android系统中包名（例如格式：com.hiveview.tv）是唯一标示一个应用的ID）</p><p><b>shell模式:</b><br><br>命令窗口 adb shell 是进入Linux命令模式了，进入此模式之后，ls，cd ,rm 等命令都可用使用了.</p><p><b>把本地文件放到设备端:</b><br><br>adb push D:\file.txt system/        <br><br>file.text是本地文件<br><br>system是设备路径</p><p><b>把设备端文件放置到本地电脑:</b><br><br>adb pull system/file.txt D:/<br><br>system/file.text是设备上的文件<br><br>D:/是本地路径</p><p><b>截屏:</b><br><br>adb shell 进入linux命令模式 <br><br>执行screencap -p /data/app/1.png 截屏，截屏的图片1.png即在/data/app文件夹下了</p><p><b>发送广播的命令:</b><br><br>adb shell am broadcast -a com.android.test –es test_string “this is test string” –ei test_int 100 –ez test_boolean true</p><p>－es 是传递String参数，test_string 参数key    “this is test string” 是参数值</p><p>－ei 是传递int参数，test_int 参数key    10 是参数值 </p><p>－ez 是传递boolean参数，test_boolean 参数key    true是参数值</p><p><b>启动某个activity:</b><br><br>am start -n 包(package)名/包名.活动(activity)名称启动 <br><br>云屏默认设置：am start com.android.settings/.Settings<br><br>后跟 –es 可以传递参数</p><p><b>挂载某个目录:</b><br><br>mount －o remount   /system<br>挂载某个目录，如果命令行提示文件只有读权限，建议执行此命令挂一下此目录</p><p><b>查看内存使用情况:</b><br><br>adb shell  模式下：cat /proc/meminfo <br><br>详情解释:<a href="http://www.jbxue.com/LINUXjishu/9930.html" target="_blank" rel="noopener">http://www.jbxue.com/LINUXjishu/9930.html</a></p><p>MemTotal: 所有可用RAM大小（即物理内存减去一些预留位和内核的二进制代码大小）<br><br>MemFree: LowFree与HighFree的总和，被系统留着未使用的内存<br><br>Buffers: 用来给文件做缓冲大小<br><br>Cached: 被高速缓冲存储器（cache memory）用的内存的大小（等于 diskcache minus SwapCache ）.<br><br>SwapCached:被高速缓冲存储器（cache memory）用的交换空间的大小<br>           已经被交换出来的内存，但仍然被存放在swapfile中。用来在需要的时候很快的被替换而不需要再次打开I/O端口。 <br><br>Active: 在活跃使用中的缓冲或高速缓冲存储器页面文件的大小，除非非常必要否则不会被移作他用.<br><br>Inactive: 在不经常使用中的缓冲或高速缓冲存储器页面文件的大小，可能被用于其他途径.<br><br>HighTotal\HighFree: 该区域不是直接映射到内核空间。内核必须使用不同的手法使用该段内存。<br><br>LowTotal\LowFree: 低位可以达到高位内存一样的作用，而且它还能够被内核用来记录一些自己的数据结构。<br><br>SwapTotal: 交换空间的总大小<br><br>SwapFree: 未被使用交换空间的大小<br><br>Dirty: 等待被写回到磁盘的内存大小。<br><br>Writeback: 正在被写回到磁盘的内存大小。<br><br>AnonPages：未映射页的内存大小<br><br>Mapped: 设备和文件等映射的大小。<br><br>Slab: 内核数据结构缓存的大小，可以减少申请和释放内存带来的消耗。<br><br>SReclaimable:可收回Slab的大小<br><br>SUnreclaim：不可收回Slab的大小（SUnreclaim+SReclaimable＝Slab）<br><br>PageTables：管理内存分页页面的索引表的大小。<br><br>NFS_Unstable:不稳定页表的大小<br><br>VmallocTotal: 可以vmalloc虚拟内存大小<br><br>VmallocUsed: 已经被使用的虚拟内存大小。<br><br>VmallocChunk: largest contigious block of vmalloc area which is free</p><p><b>命令行模拟遥控器按键:</b><br><br>adb shell 进入命令模式下：input keyevent  keycode值 如：</p><p>input keyevent 4 相当于按了返回键</p><p>input keyevent 82 模拟菜单键</p><p>input keyevent 3 主页键</p><p>input keyevent 19 按上键</p><p>input keyevent 20 按下键</p><p>input keyevent 21 按左键</p><p>input keyevent 22 按右键</p><p>input keyevent 23 按确定键</p><p><b>刷ROM命令:</b><br><br>adb connect IP 连接上盒子或者电视，盒子上插上带ROM的U盘，命令窗口输入 </p><p>adb reboot recovery，之后盒子重启会直接读取ROM文件进行刷机了</p><p>串口TTL：pm list packages 查看已安装应用</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&quot;&gt;&lt;a href=&quot;#ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&quot; class=&quot;headerlink&quot; title=&quot;ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&quot;&gt;&lt;/a&gt;ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&lt;/h5&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="tools" scheme="https://github.com/DJoeyZhang/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习（六）：Sealed Classes</title>
    <link href="https://github.com/DJoeyZhang/archives/9d59608a.html"/>
    <id>https://github.com/DJoeyZhang/archives/9d59608a.html</id>
    <published>2020-02-04T08:56:00.000Z</published>
    <updated>2020-02-12T03:28:50.147Z</updated>
    
    <content type="html"><![CDATA[<h5 id="何为密封类？"><a href="#何为密封类？" class="headerlink" title="何为密封类？"></a>何为密封类？</h5><p>从文档得知：密封类用于表示受限类层次结构，此时值可以具有来自受限集的类型之一，但不能具有任何其他类型。从某种意义上说，它们是枚举类的扩展：枚举类型的值集也受到限制，但每个枚举常数仅作为单个实例存在，而密封类的子类可以具有多个实例，这些实例可以包含状态。<br><a id="more"></a></p><h5 id="如何声明-sealed-class"><a href="#如何声明-sealed-class" class="headerlink" title="如何声明 sealed class?"></a>如何声明 sealed class?</h5><p>只要在类名前加sealed修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sealed class Car &#123;</span><br><span class="line"></span><br><span class="line">    data class Maruti(val speed: Int) : Car()</span><br><span class="line">    data class Bugatti(val speed: Int, val boost: Int) : Car()</span><br><span class="line">    object NotACar : Car()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当您在when表达式中使用密封类时，使用它们的关键好处就发挥了作用。如果验证语句覆盖所有情况，则不需要向语句中添加else子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun speed(car: Car): Int = when (car) &#123;</span><br><span class="line">    is Car.Maruti -&gt; car.speed</span><br><span class="line">    is Car.Bugatti -&gt; car.speed + car.boost</span><br><span class="line">    Car.NotACar -&gt; INVALID_SPEED</span><br><span class="line">    // else clause is not required as we&apos;ve covered all the cases</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当你遇到类似场景，考虑使用密封类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;何为密封类？&quot;&gt;&lt;a href=&quot;#何为密封类？&quot; class=&quot;headerlink&quot; title=&quot;何为密封类？&quot;&gt;&lt;/a&gt;何为密封类？&lt;/h5&gt;&lt;p&gt;从文档得知：密封类用于表示受限类层次结构，此时值可以具有来自受限集的类型之一，但不能具有任何其他类型。从某种意义上说，它们是枚举类的扩展：枚举类型的值集也受到限制，但每个枚举常数仅作为单个实例存在，而密封类的子类可以具有多个实例，这些实例可以包含状态。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="kotlin" scheme="https://github.com/DJoeyZhang/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习（五）：Extension Functions</title>
    <link href="https://github.com/DJoeyZhang/archives/e32f47f4.html"/>
    <id>https://github.com/DJoeyZhang/archives/e32f47f4.html</id>
    <published>2020-02-04T08:42:00.000Z</published>
    <updated>2020-02-04T08:54:38.723Z</updated>
    
    <content type="html"><![CDATA[<h5 id="拓展函数"><a href="#拓展函数" class="headerlink" title="拓展函数"></a>拓展函数</h5><p>何为拓展函数？</p><p>正如其名称，拓展函数是这样一种函数：它可以帮助你在不触及类代码的情况下，拓展类中函数的功能。这样可以减少不必要的外部代码污染。<br><br>换句话说，在kotlin中，拓展函数允许我们通过添加新函数的方式拓展类的函数种类。被拓展的类不必属于我们（它可以是第三方库中的类）并且也不需要我们写类去集成被拓展的类。<br><br>真的？不需要使用继承！<br><br>是的，这在kotlin中是可以的。<br><br>让我们停止白话，展示一下拓展函数如何使用。<br><br><a id="more"></a><br>举一个非常简单的例子来帮助理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun Int.triple(): Int &#123;</span><br><span class="line">  return this * 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// now we can use like this</span><br><span class="line">var result = 3.triple()</span><br></pre></td></tr></table></figure></p><p>另一个例子，让我们看看拓展函数如何应用在Android的View中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun ImageView.loadImage(url: String) &#123;</span><br><span class="line">    Glide.with(context).load(url).into(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// now we can use like this</span><br><span class="line">imageView.loadImage(url)</span><br></pre></td></tr></table></figure></p><p>这看起来棒极了！<br><br>在Android开发中，有很多地方我们都可以使用kotlin的这个很酷的特性。让我合理使用它吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;拓展函数&quot;&gt;&lt;a href=&quot;#拓展函数&quot; class=&quot;headerlink&quot; title=&quot;拓展函数&quot;&gt;&lt;/a&gt;拓展函数&lt;/h5&gt;&lt;p&gt;何为拓展函数？&lt;/p&gt;
&lt;p&gt;正如其名称，拓展函数是这样一种函数：它可以帮助你在不触及类代码的情况下，拓展类中函数的功能。这样可以减少不必要的外部代码污染。&lt;br&gt;&lt;br&gt;换句话说，在kotlin中，拓展函数允许我们通过添加新函数的方式拓展类的函数种类。被拓展的类不必属于我们（它可以是第三方库中的类）并且也不需要我们写类去集成被拓展的类。&lt;br&gt;&lt;br&gt;真的？不需要使用继承！&lt;br&gt;&lt;br&gt;是的，这在kotlin中是可以的。&lt;br&gt;&lt;br&gt;让我们停止白话，展示一下拓展函数如何使用。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="kotlin" scheme="https://github.com/DJoeyZhang/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习（四）：Destructuring Declarations</title>
    <link href="https://github.com/DJoeyZhang/archives/9105f5af.html"/>
    <id>https://github.com/DJoeyZhang/archives/9105f5af.html</id>
    <published>2020-02-04T03:18:00.000Z</published>
    <updated>2020-02-04T08:41:31.084Z</updated>
    
    <content type="html"><![CDATA[<h5 id="解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。"><a href="#解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。" class="headerlink" title="解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。"></a>解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。<br></h5><h5 id="什么是解构呢？"><a href="#什么是解构呢？" class="headerlink" title="什么是解构呢？"></a>什么是解构呢？<br></h5><h6 id="解构是一个很方便的方法：用于从一个-数组-或者-数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。"><a href="#解构是一个很方便的方法：用于从一个-数组-或者-数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。" class="headerlink" title="解构是一个很方便的方法：用于从一个 数组 或者 数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。"></a>解构是一个很方便的方法：用于从一个 数组 或者 数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。<br></h6><h6 id="其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。"><a href="#其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。" class="headerlink" title="其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。"></a>其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。</h6><a id="more"></a><p>有时，利用解构去获取一个对象中的变量值是很方便的，for example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val (name, age) = developer</span><br></pre></td></tr></table></figure></p><p>现在, 我们可以像从前那样单独地使用 name 和 age 字段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(name)</span><br><span class="line">println(age)</span><br></pre></td></tr></table></figure></p><h5 id="我们通常在这些地方会用到解构声明"><a href="#我们通常在这些地方会用到解构声明" class="headerlink" title="我们通常在这些地方会用到解构声明:"></a>我们通常在这些地方会用到解构声明:</h5><ul><li>从一个函数返回两个值</li></ul><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class Developer(val name: String, val age: Int)</span><br><span class="line">fun getDeveloper(): Developer &#123;</span><br><span class="line"> // some logic</span><br><span class="line"> return Developer(name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Now, to use this function:</span><br><span class="line">val (name, age) = getDeveloper()</span><br></pre></td></tr></table></figure><h5 id="在Maps中使用解构声明"><a href="#在Maps中使用解构声明" class="headerlink" title="在Maps中使用解构声明"></a>在Maps中使用解构声明</h5><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ((key, value) in map) &#123;</span><br><span class="line"> // do something with the key and the value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当需要的时候，使用解构这个特性吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。&quot;&gt;&lt;a href=&quot;#解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。&quot; class=&quot;headerlink&quot; title=&quot;解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。&quot;&gt;&lt;/a&gt;解构声明是kotlin中的一个重要特性。我们可以利用这个特性去更好地编写应用。&lt;br&gt;&lt;/h5&gt;&lt;h5 id=&quot;什么是解构呢？&quot;&gt;&lt;a href=&quot;#什么是解构呢？&quot; class=&quot;headerlink&quot; title=&quot;什么是解构呢？&quot;&gt;&lt;/a&gt;什么是解构呢？&lt;br&gt;&lt;/h5&gt;&lt;h6 id=&quot;解构是一个很方便的方法：用于从一个-数组-或者-数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。&quot;&gt;&lt;a href=&quot;#解构是一个很方便的方法：用于从一个-数组-或者-数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。&quot; class=&quot;headerlink&quot; title=&quot;解构是一个很方便的方法：用于从一个 数组 或者 数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。&quot;&gt;&lt;/a&gt;解构是一个很方便的方法：用于从一个 数组 或者 数据存储模型（通常是嵌套的模型）中提取多个值。它可以使用在接收数据的位置（如赋值语句的左侧）。&lt;br&gt;&lt;/h6&gt;&lt;h6 id=&quot;其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。&quot;&gt;&lt;a href=&quot;#其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。&quot; class=&quot;headerlink&quot; title=&quot;其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。&quot;&gt;&lt;/a&gt;其实在ES6、7的语法中，早已支持解构的写法，这里应该是一个借鉴。&lt;/h6&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="kotlin" scheme="https://github.com/DJoeyZhang/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习（三）：Data Class</title>
    <link href="https://github.com/DJoeyZhang/archives/54c86970.html"/>
    <id>https://github.com/DJoeyZhang/archives/54c86970.html</id>
    <published>2020-02-04T02:59:00.000Z</published>
    <updated>2020-02-04T08:41:20.020Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会需要创建一个这样的类：仅用于承载数据，而无其他作用。这样的类中一些标准函数通常可以从数据中机械性的生成。在kotlin中，这种类叫做data class,被标记为 data。（e.g:java中的bean类与其set，get，toString等方法）。<br><a id="more"></a></p><h6 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h6><h6 id="In-Java"><a href="#In-Java" class="headerlink" title="In Java"></a>In Java</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Developer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Developer(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line"></span><br><span class="line">        Developer developer = (Developer) o;</span><br><span class="line"></span><br><span class="line">        if (age != developer.age) return false;</span><br><span class="line">        return name != null ? name.equals(developer.name) : developer.name == null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        int result = name != null ? name.hashCode() : 0;</span><br><span class="line">        result = 31 * result + age;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Developer&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="In-Kotlin"><a href="#In-Kotlin" class="headerlink" title="In Kotlin"></a>In Kotlin</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Developer(val name: String, val age: Int)</span><br></pre></td></tr></table></figure><p>当一个类被标记为 data class时，你不需要像Java中那样，去实现或者创建以下这些方法。</p><ul><li>hashCode()</li><li>equals()</li><li>toString()</li><li>copy()</li></ul><p>编译器会自动地创建这些内部关联，所以kotlin同样引领了一个使代码整洁的潮流。<br><br>尽管如此，data class 需要满足的需求很少：</p><ul><li>主构造函数需要至少一个参数。</li><li>所有的主构造函数参数需要被标记为val 或者 var。</li><li>Data Class不能是 abstract, open, sealed or inner这些类别.</li></ul><p>所以，当你遇到这些场景，使用data class吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会需要创建一个这样的类：仅用于承载数据，而无其他作用。这样的类中一些标准函数通常可以从数据中机械性的生成。在kotlin中，这种类叫做data class,被标记为 data。（e.g:java中的bean类与其set，get，toString等方法）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="kotlin" scheme="https://github.com/DJoeyZhang/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习（二）：apply vs with</title>
    <link href="https://github.com/DJoeyZhang/archives/8b7dec41.html"/>
    <id>https://github.com/DJoeyZhang/archives/8b7dec41.html</id>
    <published>2020-01-23T09:43:00.000Z</published>
    <updated>2020-02-04T08:41:06.923Z</updated>
    
    <content type="html"><![CDATA[<h5 id="apply-vs-with"><a href="#apply-vs-with" class="headerlink" title="apply vs with"></a>apply vs with</h5><p>Kotlin中有很多优秀的特性，我们可以利用这些特性在Kotlin中编写更好的应用程序。在所有这些特性中，apply和with是重要的特性。我们必须知道什么时候用哪一个。<br><a id="more"></a></p><h5 id="何时使用“apply”，何时使用“with”？"><a href="#何时使用“apply”，何时使用“with”？" class="headerlink" title="何时使用“apply”，何时使用“with”？"></a>何时使用“apply”，何时使用“with”？</h5><p>根据定义，apply接受一个函数，并将其作用域设置为调用apply的对象的作用域。这意味着不需要显式引用对象。Apply（）当然不仅仅是简单地设置属性。它是一个转换函数，能够在返回之前评估复杂的逻辑。最后，函数只返回相同的对象（添加了更改），因此可以在同一行代码中继续使用它。</p><h5 id="让我们看看“apply”和“with”之间的区别。"><a href="#让我们看看“apply”和“with”之间的区别。" class="headerlink" title="让我们看看“apply”和“with”之间的区别。"></a>让我们看看“apply”和“with”之间的区别。</h5><p>主要有两个区别：</p><ul><li>apply接受一个实例作为接收器，而with要求将一个实例作为参数传递。在这两种情况下，实例都将成为一个块内的实例。</li><li>apply返回接收器，with返回其块中最后一个表达式的结果。</li></ul><p>通常在需要对对象执行操作并返回时使用apply。当需要对某个对象执行某些操作并返回可用于的其他对象时。</p><h5 id="Example-of-apply"><a href="#Example-of-apply" class="headerlink" title="Example of apply"></a>Example of apply</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun getDeveloper(): Developer &#123;</span><br><span class="line">    return Developer().apply &#123;</span><br><span class="line">        developerName = &quot;Amit Shekhar&quot;</span><br><span class="line">        developerAge = 22</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Example-of-with"><a href="#Example-of-with" class="headerlink" title="Example of with"></a>Example of with</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun getPersonFromDeveloper(developer: Developer): Person &#123;</span><br><span class="line">    return with(developer) &#123;</span><br><span class="line">        Person(developerName, developerAge)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;apply-vs-with&quot;&gt;&lt;a href=&quot;#apply-vs-with&quot; class=&quot;headerlink&quot; title=&quot;apply vs with&quot;&gt;&lt;/a&gt;apply vs with&lt;/h5&gt;&lt;p&gt;Kotlin中有很多优秀的特性，我们可以利用这些特性在Kotlin中编写更好的应用程序。在所有这些特性中，apply和with是重要的特性。我们必须知道什么时候用哪一个。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="kotlin" scheme="https://github.com/DJoeyZhang/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin学习（一）：lateinit vs lazy</title>
    <link href="https://github.com/DJoeyZhang/archives/286767e7.html"/>
    <id>https://github.com/DJoeyZhang/archives/286767e7.html</id>
    <published>2020-01-23T09:01:00.000Z</published>
    <updated>2020-02-04T08:40:53.658Z</updated>
    
    <content type="html"><![CDATA[<h5 id="作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。"><a href="#作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。" class="headerlink" title="作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。"></a>作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。</h5><a id="more"></a><h5 id="lateinit-vs-lazy"><a href="#lateinit-vs-lazy" class="headerlink" title="lateinit vs lazy"></a>lateinit vs lazy</h5><p>Kotlin中有很多优秀的特性，我们可以利用这些特性在Kotlin中编写更好的应用程序。在这些特性中，lateinit和lazy是重要的属性初始化特性。我们必须知道何时使用哪个属性初始化。</p><h5 id="Kotlin-Property-Initialization"><a href="#Kotlin-Property-Initialization" class="headerlink" title="Kotlin Property Initialization"></a>Kotlin Property Initialization</h5><p>如果不想在构造函数中初始化属性，那么这里有两个重要方法可以完成初始化属性。</p><ul><li>lateinit</li><li>lazy</li></ul><h5 id="lateinit"><a href="#lateinit" class="headerlink" title="lateinit"></a>lateinit</h5><p>lateinit是延迟初始化。</p><p>通常，声明为具有非空类型的属性必须在构造函数中初始化。然而，这通常并不方便。例如，我想通过依赖注入或在单元测试的设置方法中进行初始化操作。在这种情况下，我不能在构造函数中直接初始化这些属性，但如果我这么做了，在方法体内引用到这些属性变量时，编译器会给我报错。</p><p>为了解决这种问题，你可以给属性标记lateinit字段。</p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">  lateinit var mock: Mock</span><br><span class="line"></span><br><span class="line">  @SetUp fun setup() &#123;</span><br><span class="line">     mock = Mock()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test fun test() &#123;</span><br><span class="line">     mock.do()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个修饰符只能用在类主体（而不是在主构造函数中）内声明的var属性，并且只能在该属性没有自定义getter或setter时使用。属性的类型必须为非空，并且不能是基元类型。</p><h5 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h5><p>lazy是惰性初始化。</p><p>lazy（）是一个接受lambda并返回lazy实例的函数，该实例可以作为实现lazy属性的委托：get（）的第一个调用执行传递给lazy（）的lambda并记住结果，get（）的后续调用只返回记住的结果。</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  val name: String by lazy &#123; “Amit Shekhar” &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以第一次和随后的调用，name会返回“Amit Shekhar”</p><h5 id="如何选择何时使用哪一个？"><a href="#如何选择何时使用哪一个？" class="headerlink" title="如何选择何时使用哪一个？"></a>如何选择何时使用哪一个？</h5><ul><li>lazy只能用于val属性，而lateinit只能应用于vars，因为它不能编译为最终字段，因此不能保证不变性。</li><li>lateinit变量可以从任何能看到对象的地方初始化。如果您希望您的属性以一种事先未知的方式从外部初始化，请使用lateinit。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。&quot;&gt;&lt;a href=&quot;#作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。&quot; class=&quot;headerlink&quot; title=&quot;作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。&quot;&gt;&lt;/a&gt;作为Google的亲儿子，kotlin开发Android应用具有工具多样，上手容易等优势。从语言发展的角度来看，kotlin可以称作为程序员设计的语言。基本语法大家可以去官方文档看，这里我们讨论一些需要注意的地方。&lt;/h5&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="kotlin" scheme="https://github.com/DJoeyZhang/tags/kotlin/"/>
    
  </entry>
  
</feed>
