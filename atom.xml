<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>权译&#39;s  Blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DJoeyZhang/"/>
  <updated>2019-11-04T03:49:34.695Z</updated>
  <id>https://github.com/DJoeyZhang/</id>
  
  <author>
    <name>权译</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-Native开发之VSCode配置规范</title>
    <link href="https://github.com/DJoeyZhang/archives/d0170db3.html"/>
    <id>https://github.com/DJoeyZhang/archives/d0170db3.html</id>
    <published>2019-11-04T02:39:00.000Z</published>
    <updated>2019-11-04T03:49:34.695Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码风格及检查"><a href="#代码风格及检查" class="headerlink" title="代码风格及检查"></a>代码风格及检查</h4><p>代码风格检查目前一致认为用eslint比较好，并且目前ReactNative项目的开发基本都使用VSCode，因此进行代码规则检查使用VSCode的eslint插件。<br><a id="more"></a></p><h5 id="关于插件的安装及配置文件的生成（以下基于VSCode）"><a href="#关于插件的安装及配置文件的生成（以下基于VSCode）" class="headerlink" title="关于插件的安装及配置文件的生成（以下基于VSCode）"></a>关于插件的安装及配置文件的生成（以下基于VSCode）</h5><pre><code>1、首先是插件的安装，打开VSCode的扩展商店搜索eslint，找到以后下载并安装，重启VSCode。2、生成配置文件，使用终端执行npm install eslint (如果是全局安装加参数-g，如果是本地在项目根目录执行命令)，安装成功后eslint --init初始化eslint配置文件3、基础规则库的安装，目前使用的基础规则是eslint推荐规则及react推荐规则，因此需要npm install eslint-plugin-react4、除此之外还需要npm install babel-eslint</code></pre><p>最后，使用统一的配置文件内容覆盖自己项目中的（文件名：.eslintrc.js），目前规则还不算完整需要大家来填充修改</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>eslintrc.js</p><h5 id="代码格式化篇"><a href="#代码格式化篇" class="headerlink" title="代码格式化篇"></a>代码格式化篇</h5><p>prettier目前是功能比较强的代码格式化工具，可以根据eslint规则格式化代码（有一些规则可能不生效，需要单独补充）</p><p>关于插件的安装及规则设置</p><pre><code>1、首先是插件的安装，打开VSCode的扩展商店搜索prettier，找到以后下载并安装，重启VSCode。2、在usersetting 里面增加设置</code></pre><p>“prettier.eslintIntegration”: true, //让prettier使用eslint的代码格式进行校验<br>“editor.formatOnSave”: true,<br>“javascript.format.enable”: false<br>“editor.tabSize”: 4,<br>“editor.detectIndentation”: false,</p><p>注意事项：<br>公共文件，最好不要做代码格式化，容易在代码merge时引起许多冲突</p><p>如果需求格式化，约定在项目提测前，某个人格式化，然后其他人及时同步一下</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;代码风格及检查&quot;&gt;&lt;a href=&quot;#代码风格及检查&quot; class=&quot;headerlink&quot; title=&quot;代码风格及检查&quot;&gt;&lt;/a&gt;代码风格及检查&lt;/h4&gt;&lt;p&gt;代码风格检查目前一致认为用eslint比较好，并且目前ReactNative项目的开发基本都使用VSCode，因此进行代码规则检查使用VSCode的eslint插件。&lt;br&gt;
    
    </summary>
    
    
      <category term="VsCode,React-native" scheme="https://github.com/DJoeyZhang/tags/VsCode-React-native/"/>
    
  </entry>
  
  <entry>
    <title>Debounce函数及lodash库的一些思考</title>
    <link href="https://github.com/DJoeyZhang/archives/20cd7dd6.html"/>
    <id>https://github.com/DJoeyZhang/archives/20cd7dd6.html</id>
    <published>2019-01-21T06:05:00.000Z</published>
    <updated>2019-01-22T07:28:19.011Z</updated>
    
    <content type="html"><![CDATA[<p>hybrid-native开发或者reat-native开发时，不可避免涉及到js脚本编写。对于大前端来说，对于es6/es7的语法熟悉是必备素质。这里介绍一个前端常用的工具库lodash。<br><a id="more"></a></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>今天在优化大搜索页面时碰到一个问题，feedback返回用户反馈搜索页面卡顿。先定位到原先的代码：是在 &lt; TextInput &gt; 的onchange回调中，请求suggest接口返回模糊搜索结果。但是在IOS设备上会有一个问题：键盘输入拼音时系统会把未输入完的结果录到input组建中，导致onchange回调多次调用，suggest接口频繁请求，hint内容不断刷新，造成页面卡顿的同时，也增加了接口的负担。</p><h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><p>经过分析，我认为用户使用模糊搜索具备 <a href="http://f.dataguru.cn/spark-888363-1-1.html" target="_blank" rel="noopener">幂等性</a> .即在一段时间内用户输入的key word应返回相同的suggest。不应频繁调用接口。<br>基于以上思想，很自然想到setTimeout()函数，用户输入停止后设置一个延时再请求网络,但是直接在回调里setTimeout这个做法十分hardcode。于是逛了一下万能的gayHub,发现了一个不错的解决方案:使用debounce函数去除抖动。</p><h4 id="lodash介入"><a href="#lodash介入" class="headerlink" title="lodash介入"></a>lodash介入</h4><p>这里的debounce函数属于鼎鼎大名的lodash库(<a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a>)<br><a href="https://www.lodashjs.com/docs/4.17.5.html#debounce" target="_blank" rel="noopener">debounce函数的官方文档</a></p><p><a href="https://lodash.com/docs/4.17.5" target="_blank" rel="noopener">lodash官方文档</a><br><a href="http://lodash.think2011.net/keys" target="_blank" rel="noopener">lodash中文文档</a></p><h4 id="debounce-与-throttle"><a href="#debounce-与-throttle" class="headerlink" title="debounce 与 throttle"></a>debounce 与 throttle</h4><p>debounce(防抖)：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间，举个简单的例子，我们要根据用户输入做suggest，每当用户按下键盘的时候都可以取消前一次，并且只关心最后一次输入的时间就行了。</p><p>throttle(节流)：将一个函数的调用频率限制在一定阈值内，例如 1s 内一个函数不能被调用两次。<br>这里拿出debounce的源码解析一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, options) &#123;</span><br><span class="line">    let lastArgs,</span><br><span class="line">        lastThis,</span><br><span class="line">        maxWait,</span><br><span class="line">        result,</span><br><span class="line">        timerId,</span><br><span class="line">        lastCallTime</span><br><span class="line"></span><br><span class="line">    // 参数初始化</span><br><span class="line">    let lastInvokeTime = 0 // func 上一次执行的时间</span><br><span class="line">    let leading = false</span><br><span class="line">    let maxing = false</span><br><span class="line">    let trailing = true</span><br><span class="line"></span><br><span class="line">    // 基本的类型判断和处理</span><br><span class="line">    if (typeof func != &apos;function&apos;) &#123;</span><br><span class="line">        throw new TypeError(&apos;Expected a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    wait = +wait || 0</span><br><span class="line">    if (isObject(options)) &#123;</span><br><span class="line">        // 对配置的一些初始化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function invokeFunc(time) &#123;</span><br><span class="line">        const args = lastArgs</span><br><span class="line">        const thisArg = lastThis</span><br><span class="line"></span><br><span class="line">        lastArgs = lastThis = undefined</span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        result = func.apply(thisArg, args)</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function leadingEdge(time) &#123;</span><br><span class="line">        // Reset any `maxWait` timer.</span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        // 为 trailing edge 触发函数调用设定定时器</span><br><span class="line">        timerId = setTimeout(timerExpired, wait)</span><br><span class="line">        // leading = true 执行函数</span><br><span class="line">        return leading ? invokeFunc(time) : result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   function remainingWait(time) &#123;</span><br><span class="line">        const timeSinceLastCall = time - lastCallTime // 距离上次debounced函数被调用的时间</span><br><span class="line">        const timeSinceLastInvoke = time - lastInvokeTime // 距离上次函数被执行的时间</span><br><span class="line">        const timeWaiting = wait - timeSinceLastCall // 用 wait 减去 timeSinceLastCall 计算出下一次trailing的位置</span><br><span class="line"></span><br><span class="line">        // 两种情况</span><br><span class="line">        // 有maxing:比较出下一次maxing和下一次trailing的最小值，作为下一次函数要执行的时间</span><br><span class="line">        // 无maxing：在下一次trailing时执行 timerExpired</span><br><span class="line">        return maxing</span><br><span class="line">            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class="line">            : timeWaiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据时间判断 func 能否被执行</span><br><span class="line">    function shouldInvoke(time) &#123;</span><br><span class="line">        const timeSinceLastCall = time - lastCallTime</span><br><span class="line">        const timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">        // 几种满足条件的情况</span><br><span class="line">        return (lastCallTime === undefined //首次</span><br><span class="line">            || (timeSinceLastCall &gt;= wait) // 距离上次被调用已经超过 wait</span><br><span class="line">            || (timeSinceLastCall &lt; 0) //系统时间倒退</span><br><span class="line">            || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)) //超过最大等待时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function timerExpired() &#123;</span><br><span class="line">        const time = Date.now()</span><br><span class="line">        // 在 trailing edge 且时间符合条件时，调用 trailingEdge函数，否则重启定时器</span><br><span class="line">        if (shouldInvoke(time)) &#123;</span><br><span class="line">            return trailingEdge(time)</span><br><span class="line">        &#125;</span><br><span class="line">        // 重启定时器，保证下一次时延的末尾触发</span><br><span class="line">        timerId = setTimeout(timerExpired, remainingWait(time))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function trailingEdge(time) &#123;</span><br><span class="line">        timerId = undefined</span><br><span class="line"></span><br><span class="line">        // 有lastArgs才执行，意味着只有 func 已经被 debounced 过一次以后才会在 trailing edge 执行</span><br><span class="line">        if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">            return invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">        // 每次 trailingEdge 都会清除 lastArgs 和 lastThis，目的是避免最后一次函数被执行了两次</span><br><span class="line">        // 举个例子：最后一次函数执行的时候，可能恰巧是前一次的 trailing edge，函数被调用，而这个函数又需要在自己时延的 trailing edge 触发，导致触发多次</span><br><span class="line">        lastArgs = lastThis = undefined</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function cancel() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function flush() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function pending() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function debounced(...args) &#123;</span><br><span class="line">        const time = Date.now()</span><br><span class="line">        const isInvoking = shouldInvoke(time) //是否满足时间条件</span><br><span class="line"></span><br><span class="line">        lastArgs = args</span><br><span class="line">        lastThis = this</span><br><span class="line">        lastCallTime = time  //函数被调用的时间</span><br><span class="line"></span><br><span class="line">        if (isInvoking) &#123;</span><br><span class="line">            if (timerId === undefined) &#123; // 无timerId的情况有两种：1.首次调用 2.trailingEdge执行过函数</span><br><span class="line">                return leadingEdge(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">            if (maxing) &#123;</span><br><span class="line">                // Handle invocations in a tight loop.</span><br><span class="line">                timerId = setTimeout(timerExpired, wait)</span><br><span class="line">                return invokeFunc(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 负责一种case：trailing 为 true 的情况下，在前一个 wait 的 trailingEdge 已经执行了函数；</span><br><span class="line">        // 而这次函数被调用时 shouldInvoke 不满足条件，因此要设置定时器，在本次的 trailingEdge 保证函数被执行</span><br><span class="line">        if (timerId === undefined) &#123;</span><br><span class="line">            timerId = setTimeout(timerExpired, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel</span><br><span class="line">    debounced.flush = flush</span><br><span class="line">    debounced.pending = pending</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首次进入函数时因为 lastCallTime === undefined 并且 timerId === undefined，所以会执行 leadingEdge，如果此时 leading 为 true 的话，就会执行 func。同时，这里会设置一个定时器，在等待 wait(s) 后会执行 timerExpired，timerExpired 的主要作用就是触发 trailing。</p><p>如果在还未到 wait 的时候就再次调用了函数的话,会更新 lastCallTime，并且因为此时 isInvoking 不满足条件，所以这次什么也不会执行。</p><p>时间到达 wait 时，就会执行我们一开始设定的定时器timerExpired，此时因为time-lastCallTime &lt; wait，所以不会执行 trailingEdge。</p><p>这时又会新增一个定时器，下一次执行的时间是 remainingWait，这里会根据是否有 maxwait 来作区分：</p><p>如果没有 maxwait，定时器的时间是 wait - timeSinceLastCall，保证下一次 trailing 的执行。</p><p>如果有 maxing，会比较出下一次 maxing 和下一次 trailing 的最小值，作为下一次函数要执行的时间。</p><p>最后，如果不再有函数调用，就会在定时器结束时执行 trailingEdge。</p><h4 id="lodash其他常用函数："><a href="#lodash其他常用函数：" class="headerlink" title="lodash其他常用函数："></a>lodash其他常用函数：</h4><p><strong>遍历对象类型：</strong><br>_.forEach(obj, (value, key) =&gt; { console.log(value) })</p><p><strong>遍历和过滤的快捷方式：</strong><br>从一组对象中摘取出某个属性的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#123; n: 1 &#125;, &#123; n: 2 &#125;]</span><br><span class="line">// ES6</span><br><span class="line">arr.map((obj) =&gt; obj.n)</span><br><span class="line">// Lodash</span><br><span class="line">_.map(arr, &apos;n&apos;)</span><br></pre></td></tr></table></figure></p><p>当对象类型的嵌套层级很多时，Lodash 的快捷方式就更实用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">  &#123; a: [ &#123; n: 1 &#125; ]&#125;,</span><br><span class="line">  &#123; b: [ &#123; n: 1 &#125; ]&#125;</span><br><span class="line">]</span><br><span class="line">// ES6</span><br><span class="line">arr.map((obj) =&gt; obj.a[0].n) // TypeError: 属性 &apos;a&apos; 在 arr[1] 中未定义</span><br><span class="line">// Lodash</span><br><span class="line">_.map(arr, &apos;a[0].n&apos;) // =&gt; [1, undefined]</span><br></pre></td></tr></table></figure></p><p>可以看到，Lodash 的快捷方式还对 null 值做了容错处理。此外还有过滤快捷方式，以下是从 Lodash 官方文档中摘取的示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let users = [</span><br><span class="line">  &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36, &apos;active&apos;: true &#125;,</span><br><span class="line">  &#123; &apos;user&apos;: &apos;fred&apos;,   &apos;age&apos;: 40, &apos;active&apos;: false &#125;</span><br><span class="line">];</span><br><span class="line">// ES6</span><br><span class="line">users.filter((o) =&gt; o.active)</span><br><span class="line">// Lodash</span><br><span class="line">_.filter(users, &apos;active&apos;)</span><br><span class="line">_.filter(users, [&apos;active&apos;, true])</span><br><span class="line">_.filter(users, &#123;&apos;active&apos;: true, &apos;age&apos;: 36&#125;)</span><br></pre></td></tr></table></figure></p><p><strong> 链式调用和惰性求值:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">et lines = `</span><br><span class="line">an apple orange the grape</span><br><span class="line">banana an apple melon</span><br><span class="line">an orange banana apple</span><br><span class="line">`.split(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">_.chain(lines)</span><br><span class="line">  .flatMap(line =&gt; line.split(/\s+/))</span><br><span class="line">  .filter(word =&gt; word.length &gt; 3)</span><br><span class="line">  .groupBy(_.identity)</span><br><span class="line">  .mapValues(_.size)</span><br><span class="line">  .forEach((count, word) =&gt; &#123; console.log(word, count) &#125;)</span><br><span class="line"></span><br><span class="line">// apple 3</span><br><span class="line">// orange 2</span><br><span class="line">// grape 1</span><br><span class="line">// banana 2</span><br><span class="line">// melon 1</span><br></pre></td></tr></table></figure></p><p><strong>解构赋值和箭头函数:</strong><br>ES6 引入了解构赋值、箭头函数等新的语言特性，可以用来替换 Lodash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Lodash</span><br><span class="line">_.head([1, 2, 3]) // =&gt; 1</span><br><span class="line">_.tail([1, 2, 3]) // =&gt; [2, 3]</span><br><span class="line">// ES6 解构赋值（destructuring syntax）</span><br><span class="line">const [head, ...tail] = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// Lodash</span><br><span class="line">let say = _.rest((who, fruits) =&gt; who + &apos; likes &apos; + fruits.join(&apos;,&apos;))</span><br><span class="line">say(&apos;Jerry&apos;, &apos;apple&apos;, &apos;grape&apos;)</span><br><span class="line">// ES6 spread syntax</span><br><span class="line">say = (who, ...fruits) =&gt; who + &apos; likes &apos; + fruits.join(&apos;,&apos;)</span><br><span class="line">say(&apos;Mary&apos;, &apos;banana&apos;, &apos;orange&apos;)</span><br><span class="line"></span><br><span class="line">// Lodash</span><br><span class="line">_.constant(1)() // =&gt; 1</span><br><span class="line">_.identity(2) // =&gt; 2</span><br><span class="line">// ES6</span><br><span class="line">(x =&gt; (() =&gt; x))(1)() // =&gt; 1</span><br><span class="line">(x =&gt; x)(2) // =&gt; 2</span><br><span class="line"></span><br><span class="line">// 偏应用（Partial application）</span><br><span class="line">let add = (a, b) =&gt; a + b</span><br><span class="line">// Lodash</span><br><span class="line">let add1 = _.partial(add, 1)</span><br><span class="line">// ES6</span><br><span class="line">add1 = b =&gt; add(1, b)</span><br><span class="line"></span><br><span class="line">// 柯里化（Curry）</span><br><span class="line">// Lodash</span><br><span class="line">let curriedAdd = _.curry(add)</span><br><span class="line">let add1 = curriedAdd(1)</span><br><span class="line">// ES6</span><br><span class="line">curriedAdd = a =&gt; b =&gt; a + b</span><br><span class="line">add1 = curriedAdd(1)</span><br></pre></td></tr></table></figure></p><h4 id="一些参考信息："><a href="#一些参考信息：" class="headerlink" title="一些参考信息："></a>一些参考信息：</h4><p><a href="https://www.sitepoint.com/lodash-features-replace-es6/" target="_blank" rel="noopener">10 Lodash Features You Can Replace with ES6</a><br><a href="https://derickbailey.com/2016/09/12/does-es6-mean-the-end-of-underscore-lodash/" target="_blank" rel="noopener">Does ES6 Mean The End Of Underscore / Lodash?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hybrid-native开发或者reat-native开发时，不可避免涉及到js脚本编写。对于大前端来说，对于es6/es7的语法熟悉是必备素质。这里介绍一个前端常用的工具库lodash。&lt;br&gt;
    
    </summary>
    
    
      <category term="open " scheme="https://github.com/DJoeyZhang/tags/open/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题及一些思考</title>
    <link href="https://github.com/DJoeyZhang/archives/f8185732.html"/>
    <id>https://github.com/DJoeyZhang/archives/f8185732.html</id>
    <published>2019-01-08T06:42:00.000Z</published>
    <updated>2019-01-16T11:06:42.305Z</updated>
    
    <content type="html"><![CDATA[<p>所谓,温故而知新，可以为师矣！这段时间到处面试，结合工作和网上一些文章，深感学有涯而知无涯~<br>在这里梳理一下，供学习思考。本篇主要是 native开发涉及到的Java知识点和Android方面知识。<br></p><hr><a id="more"></a><h3 id="JAVA基础-Android原生开发Java多线程问题必问"><a href="#JAVA基础-Android原生开发Java多线程问题必问" class="headerlink" title="JAVA基础(Android原生开发Java多线程问题必问):"></a>JAVA基础(Android原生开发Java多线程问题必问):</h3><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别?"></a>线程和进程的区别?</h4><p>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，<br>而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><h4 id="线程池的概念以及应用场景"><a href="#线程池的概念以及应用场景" class="headerlink" title="线程池的概念以及应用场景?"></a>线程池的概念以及应用场景?</h4><p>多线程编程下如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务,线程池技术的出现就很好的解决了上面问题,可以更好的提供性能,并有效控制系统中并发线程的数量(线程池的最大线程数参数可以控制系统中并发线程数不超过此数)。</p><p><a href="https://www.cnblogs.com/ruiati/p/6134131.html" target="_blank" rel="noopener">关于Java四种类型线程池详解</a></p><h4 id="volatitle与synchronize区别，锁的两种特性：可见性与互斥性"><a href="#volatitle与synchronize区别，锁的两种特性：可见性与互斥性" class="headerlink" title="volatitle与synchronize区别，锁的两种特性：可见性与互斥性? "></a><strong>volatitle与synchronize区别，锁的两种特性：可见性与互斥性? </strong></h4><p>首先，二者都是保证了在竞态条件下，数据的一致性。<br>使用上：volatile只用来声明变量；synchronize可以用来修饰方法体。</p><p>volatile，它能够使变量在值发生改变时尽快地让其他线程知道。<br>所谓可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。它在某些情况下比synchronized的开销更小，如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p><strong> Volatile使用场景：</strong><br>常见的就是单例模式中,对字段的声明,加上这个关键字。保证在不同线程中单例属性的有效性。</p><p><strong> Volatile原理:</strong><br>先将当前处理器缓存行的数据会写回到系统内存,这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。最后,当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。如此循环反复保证共享变量的值是一致的。</p><p><strong> synchronize的理解及原理：</strong><br>A: 每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：<br>    1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。<br>    2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.<br>    3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p><p>B:执行monitorexit的线程必须是objectref所对应的monitor的所有者。<br>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><p>volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取。synchronized则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞。</p><h4 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全?"></a>如何保证线程安全?</h4><p>简单来说，线程安全就是：在多线程环境中，能永远保证程序的正确性。因此,只有存在共享数据时才需要考虑线程安全问题。</p><p>解决方案1:Java多线程支持引入同步监视器来解决这个问题,使用同步监视器的通用方法就是同步代码块,使用synchronize(obj)代码块,(目的:任何时刻只能有一个线程可以获得对同步监视器的锁定,当同步代码块执行完成后,该线程会释放对该同步监视器的锁定) 推荐使用可能被并发访问的共享资源充当同步监视器,逻辑大概就是   加锁–&gt;修改–&gt;释放锁 </p><p>解决方案2:通过显示定义同步锁对象实现同步,在这种机制下,同步锁用Lock对象充当,Lock允许实现更灵活的结构,有差别很大的属性,使用Lock对象来进行同步,加锁和释放锁出现在不同的作用范围内,通常建议使用finally块来确保在必要时候释放锁。</p><h4 id="简述Java中为什么会出现死锁"><a href="#简述Java中为什么会出现死锁" class="headerlink" title="简述Java中为什么会出现死锁?"></a>简述Java中为什么会出现死锁?</h4><p>当两个线程相互等待对方释放同步监视器时就会发生死锁,Java虚拟机没有监测也没有采取措施来处理死锁情况,所以多线程编程时应该采取措施避免死锁出现.一旦出现死锁,整个程序既不会发生任何异常,也不会给出任何提示,只是所有线程处于阻塞状态,无法继续。</p><h4 id="简述多态"><a href="#简述多态" class="headerlink" title="简述多态?"></a>简述多态?</h4><p>一句话:父类引用指向子类对象。Father f = new Son();<br>概念：个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>由多态引申的概念:向上转型</p><p>它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</p><p><strong>Java实现多态有三个必要条件：继承、重写、向上转型。</strong></p><h4 id="对Java的理解"><a href="#对Java的理解" class="headerlink" title="对Java的理解?"></a>对Java的理解?</h4><p>可以从面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点谈。桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序,Android开发等等回答.</p><p><strong>抽象类与接口的联系与区别?</strong><br>相同点:<br>都不能直接实例化,接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化。</p><p>区别:<br>1、抽象类变量必须指向实现所有<strong>抽象方法</strong>的子类对象;接口变量必须指向实现所有<strong>接口</strong>方法的类对象。<br>2、抽象类要被子类继承(extends)，接口要被类实现(implement)。<br>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。<br>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个类实现接口的时候，如不能实现接口中全部方法，那么该类也只能为抽象类。<br>6、抽象方法只能声明，不能实现。abstract void abc();不能写成abstract void abc(){}。<br>7、抽象类里可以没有抽象方法。但一个类里有抽象方法，那么这个类只能是抽象类。<br>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。<br>10、接口可继承接口，并可多继承接口，但类只能单继承。</p><p>综述 : 特别是对于公用的实现代码，抽象类有它的优点。抽象类能够保证实现的层次关系，避免代码重复。然而，即使在使用抽象类的场合，也不要忽视通过接口定义行为模型的原则。从实践的角度来看，如果依赖于抽象类来定义行为，往往导致过于复杂的继承关系，而通过接口定义行为能够更有效地解耦，为代码的维护和修改带来方便。</p><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h4><p><strong> 值传递。</strong><br>Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p><h4 id="java数据类型（精度丢失，强制转型）-数据结构"><a href="#java数据类型（精度丢失，强制转型）-数据结构" class="headerlink" title="java数据类型（精度丢失，强制转型）/ 数据结构"></a>java数据类型（精度丢失，强制转型）/ 数据结构</h4><p><strong> float f=2.3;是否正确?</strong><br>不正确。<br>2.3是双精度数，将双精度型(double)赋值给浮点型(float)属于下转型(down-casting，也称为窄化)会造成精度损失，因此需要强制类型转换float f =(float)2.3; 或者写成float f =2.3F;。</p><p><strong> short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</strong><br>对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。<br>而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p><p><strong> StringBuffer和StringBuilder的区别?</strong><br>StringBuilder：线程非安全的,但是效率高<br>StringBuffer：线程安全的,效率相对较低<br>单线程操作字符串缓冲区下操作大量数据推荐使用:StringBuilder<br>多线程操作字符串缓冲区下操作大量数据推荐使用:StringBuffer</p><p><strong> 数组和链表的区别？</strong><br>二者都属于一种数据结构。</p><p>从逻辑结构来看：<br>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标直接存取。</p><p>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项，非常繁琐）链表必须根据next指针找到下一个元素。</p><p>从内存存储来看：<br>(静态)数组从栈中分配空间, 对于程序员方便快速,但是自由度小。</p><p>链表从堆中分配空间, 自由度大但是申请管理比较麻烦。</p><p><strong> 从上面的比较可以看出，如果需要快速访问数据，很少或不插入和删除元素，就应该用数组；相反， 如果需要经常插入和删除元素就需要用链表数据结构了。</strong></p><h4 id="简述Java中的四种引用"><a href="#简述Java中的四种引用" class="headerlink" title="简述Java中的四种引用?"></a>简述Java中的四种引用?</h4><ul><li><strong>强引用（StrongReference）</strong><br>强引用是使用最普遍的引用。比如new 对象等等,如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</li><li><strong>软引用（SoftReference）</strong><br>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。软引用可用来实现内存敏感的高速缓存。</li><li><strong>弱引用（WeakReference）</strong><br>在java中，用java.lang.ref.WeakReference类来表示弱引用.  与软引用的区别在于：弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</li><li><strong>虚引用（PhantomReference）</strong><br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。</li></ul><p><strong> 强引用置为null,会不会被回收? </strong><br>只要是强引用就证明这个内存是在的，但是置为null,因此回收器在适当的时候回收,什么是适当时候，大体是使用内存占申请内存75%的时候，就启动回收线程。</p><p><strong> 如何保证多线程读写文件的安全? </strong><br>加锁,可以参考上面的线程安全</p><h4 id="单例模式的常见写法和优缺点分析"><a href="#单例模式的常见写法和优缺点分析" class="headerlink" title="单例模式的常见写法和优缺点分析?"></a>单例模式的常见写法和优缺点分析?</h4><p><strong> 懒汉式：</strong><br>第一次获取单例类的实例时创建。(优点:写法简单，且不存在多线程同步问题，避免了synchronized所造成的性能问题；缺点是：初始化类的时候就需要构造实例，（即便你还没有用到这个实例），因此在某些特定条件下会耗费内存。)<br><strong> 饿汉式：</strong><br>在类被加载的时候创建单例类的对象，类加载器负责加载类，并会保证只有一个线程在实例化单例类， (优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。缺点：在类装载的时候就完成实例化，没有达到Lazy Load的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。)</p><p>单例模式个人觉得最经典在项目里经常使用的写法（也称<strong>双重锁机制</strong>）：<br><a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">更多细节可以参考单例模式的8种写法</a></p><h4 id="单例模式的拓展？"><a href="#单例模式的拓展？" class="headerlink" title="单例模式的拓展？"></a>单例模式的拓展？</h4><p><strong> 使用静态内部类 实现单例模式 </strong></p><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，在《java并发编程实践》一书中推荐使用静态内部类单例模式。当然，可以根据个人偏好去使用。</p><p><strong> 实现管理者模式 </strong></p><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象，代码可读性强。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p><h4 id="网络请求-加密-持久化"><a href="#网络请求-加密-持久化" class="headerlink" title="网络请求 / 加密 / 持久化?"></a>网络请求 / 加密 / 持久化?</h4><p><strong> Http,Https相关? </strong></p><p>Http: (HTTP-Hypertext transfer protocol)又称:超文本传输协议 , 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p><p>Https:（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。Https情况下,电脑与服务器之间收发的信息传输将更加安全。</p><p><strong> HTTP协议的主要特点可概括如下：</strong></p><p>1.支持客户/服务器模式。</p><p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p><strong>Cookie 、Session  、 Token相关?</strong></p><p>Cookie:  它是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以key - Value 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的.(Cookie的作用是为了解决HTTP协议无状态的缺陷所作的努力)</p><p>cookie的内容主要包括：名字、值、过期时间、路径和域。<br>路径与域一起构成cookie的作用范围。<br>若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie.会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为 并不是规范规定的。<br>若设置了过期时间，浏览器就会把cookie保存在硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里cookie，不同的浏览器有不同的处理方式。</p><p>Session : 当用户打开某个web应用时，便与web服务器产生一次session。</p><p>简单的理解就是 : 服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。</p><p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对Cookie来说更安全 . 但是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p><p>Token: (英译汉 : 象征; 记号; 代币;)<br>token是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。</p><p><strong>Cookie和Session的区别:</strong></p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><ul><li>将登陆信息等重要信息存放为session</li><li>其他信息如果需要保留，可以放在cookie中</li></ul><p><strong>Token 和 Session 的区别: </strong></p><p>session和 token并不矛盾，作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。</p><p>如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态<br>App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。如果你的后端不是stateless的rest api,那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session.</p><p>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session认证只是简单的把User信息存储到Session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而Token，如果指的是OAuth Token或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App。其目的是让 某App有权利访问 某用户 的信息。</p><p>这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它 用户 上。转过来说Session。Session只提供一种简单的认证，即有此SID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么就无所谓了。</p><p>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；</p><p>cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；</p><p>session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p><h4 id="加密相关"><a href="#加密相关" class="headerlink" title="加密相关"></a>加密相关</h4><p><strong>对称加密: </strong></p><p>同一个密钥可以同时用作信息的加密和解密(注意:是同一个密钥)，这种加密方法称为对称加密，也称为单密钥加密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。因此,(“ target=”_blank”&gt;加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。在对称加密中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。接收方收到密文后，若想解读原文，则需要使用加密密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密。</p><p>对称加密算法的优点:算法公开、计算量小、加密速度快、加密效率高。</p><p>对称加密算法的缺点:在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p><p>对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。</p><p><strong>非对称加密:</strong></p><p>非对称加密算法需要两个密钥来进行加密和解密。<br>这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p><p>非对称加密与对称加密相比，其安全性更好：对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p><p>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><p><strong>MD5:</strong><br>MD5是一种信息摘要算法, 消息摘要是一种与消息认证码结合使用以确保消息完整性的技术。主要使用单向散列函数算法，可用于检验消息的完整性，和通过散列密码直接以文本形式保存等，目前广泛使用的算法有MD4、MD5、SHA-1。</p><h3 id="Android-UI-NetWork-handler"><a href="#Android-UI-NetWork-handler" class="headerlink" title="Android(UI / NetWork / handler):"></a>Android(UI / NetWork / handler):</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏:"></a>内存泄漏:</h4><p>当应用内部不再需要某个实例后，但是这个对象却仍然被引用，这个情况就叫做内存泄露(Memory Leak)。安卓虚拟机为每一个应用分配一定的内存空间，当内存泄露到达一定的程度就会造成内存溢出。</p><p><strong>导致内存泄露常见原因:</strong></p><ul><li>静态变量直接或者间接地引用了Activity对象就会造成内存泄露</li><li>Activity使用了静态的View(View会持有Activity的对象的引用)</li><li>ImageSpan引用了Activity Context</li><li>单例中引用了Activity的Context(需要使用Application的Context)</li><li>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏。</li><li>静态集合保存的对象没有及时消除(不使用的时候置为null)</li><li>在Java中,非静态(匿名)内部类会引用外部类对象,而静态内部类不会引用外部类对象</li><li>在Activity中,创建了非静态内部类(内部类直接或者间接引用了Activity)的静态成员变量</li><li>线程包括AsyncTask的使用,Activity退出后线程还在运行(线程在死循环),并且在线程中使用了Activity或view对象(解决方法:不要直接写死循环,可以设置一个布尔类型的TAG,当activity推出的时候,设置TAG为False)</li><li>Handler对象的使用,Activity退出后Handler还是有消息需要处理(解决方法:在退出activity之后,移除消息)</li><li>WebView造成的内存泄漏(在onDestory中销毁)</li></ul><p><strong>如何进行内存泄露分析?</strong></p><p>A: 通过Android Studio 窗口进行分析,查看内存分配情况,如果操作应用是内存一直往上涨说明存在内存泄露<br>B: 定位内存泄露分析的工具—MAT(Memory Analyzer tool)<br>C: 使用开源库LeakCanary快速定位内存泄露</p><h4 id="ANR相关"><a href="#ANR相关" class="headerlink" title="ANR相关"></a>ANR相关</h4><p>ANR全名Application Not Responding, 也就是”应用无响应”. 当操作在一段时间内系统无法处理时, 系统层面会弹出上图那样的ANR对话框.<br>在Android里, App的响应能力是由Activity Manager和Window Manager系统服务来监控的. 通常在如下两种情况下会弹出ANR对话框:</p><ul><li>5s内无法响应用户输入事件(例如键盘输入, 触摸屏幕等).</li><li>BroadcastReceiver在10s内无法结束.<br>造成以上两种情况的首要原因就是在主线程(UI线程)里面做了太多的阻塞耗时操作,例如文件读写, 数据库读写, 网络查询等等.</li></ul><h4 id="如何分析ANR"><a href="#如何分析ANR" class="headerlink" title="如何分析ANR?"></a>如何分析ANR?</h4><p>ANR产生时, 系统会生成一个traces.txt的文件放在/data/anr/下. 开发人员可通过adb命令将其导出到本地 (<strong>$ adb pull data/anr/traces.txt</strong>)通过分析,我们可以根据具体的日志查看Anr原因( 如: 普通阻塞,CPU满负荷,内存泄露 )</p><h4 id="Android开发下如何有效进行屏幕适配"><a href="#Android开发下如何有效进行屏幕适配" class="headerlink" title="Android开发下如何有效进行屏幕适配?"></a>Android开发下如何有效进行屏幕适配?</h4><ul><li>机型适配，去一些统计网站诸如友盟,现在叫友盟+去看一下市场上最流行的Android机型,有针对性的切图</li><li>屏幕适配，适配主流xhdpi屏幕尺寸，使用relativelayout，linerlayout等布局，多使用matchparent，wrapcontent，及配合weight,权重处理，</li><li>还有就是在代码中，设计到具体尺寸的要使用dp2px的转换，</li><li>图片使用可拉伸.9图片，imageview使用scaletype缩放；</li><li>使用权重,等比例,百分比布局等等.</li></ul><h4 id="今日头条屏幕适配的原理？"><a href="#今日头条屏幕适配的原理？" class="headerlink" title="今日头条屏幕适配的原理？"></a>今日头条屏幕适配的原理？</h4><p>首先计算出 density，计算公式：当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = densitydensity .<br>意思就是 1 dp 占当前设备多少像素计算density .<br>原因：在布局文件中填写的是什么单位，最后都会被转化为 px，系统就是通过上面的方法，将你在项目中任何地方填写的单位都转换为 px</p><p>但是，今日头条适配方案默认项目中只能以高或宽中的一个作为基准，来进行适配.</p><h4 id="Android下的数据存储方式有那些"><a href="#Android下的数据存储方式有那些" class="headerlink" title="Android下的数据存储方式有那些?"></a>Android下的数据存储方式有那些?</h4><ul><li>内部存储,直接存储在内部文件中</li><li>外部存储,首先要判断外部存储条件是否可用,然后进行存储</li><li>SP存储,底层是Xml实现的,以键值对形式存储内部的数据,适宜于轻量级的存储,存储的数据类型有,boolean,String,int</li><li>数据库存储,SQlite存储,轻量级的数据库,强大的增删改查功能</li><li>内容提供者,ContentProvider,将自己愿意暴露的一部分数据供外部使用操作</li><li>网络存储,等等</li></ul><h4 id="Sharepreference-线程安全问题？"><a href="#Sharepreference-线程安全问题？" class="headerlink" title="Sharepreference 线程安全问题？"></a>Sharepreference 线程安全问题？</h4><p>SharedPreferences不支持多进程，如果需要多进程通信，优先选择contentProvider。</p><p><strong>commit和apply方法的区别：</strong></p><p>commit和apply都是原子性操作。</p><p>commit是原子提交到数据库，所以从提交数据到存在Disk中都是同步过程，中间不可打断。</p><p>apply方法的原子操作是原子提交的内存中，而非数据库，所以在提交到内存中时不可打断，之后再异步提交数据到数据库中，因此也不会有相应的返回值。</p><p>所有commit提交是同步过程，效率会比apply异步提交的速度慢，但是apply没有返回值，永远无法知道存储是否失败。<br>在不关心提交结果是否成功的情况下，优先考虑apply方法。</p><h4 id="假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据"><a href="#假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据" class="headerlink" title="假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据?"></a>假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据?</h4><p>解决办法就是：将需要共享数据的字段提出来统一存储到一个文件中。但是多进程访问一个文件时，不能保证信息的安全性。（这里我也没想到解决办法，欢迎各位斧正）</p><h4 id="对象序列化："><a href="#对象序列化：" class="headerlink" title="对象序列化："></a>对象序列化：</h4><p><strong> 为什么要序列化？</strong></p><ul><li>永久性保存对象，保存对象的字节序列到本地文件中；</li><li>通过序列化对象在网络中传递对象；</li><li>通过序列化在进程间传递对象。</li></ul><p><strong>在Android中实现序列化有两个选择：</strong></p><p>一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。</p><p>实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。</p><p>Google推荐Parcelable这种序列化，在这里，推荐一键生成序列化的插件:<a href="https://blog.csdn.net/shanshan_1117/article/details/80500512" target="_blank" rel="noopener">Android Parcelable code generators</a></p><h4 id="简述Android中的加固和使用平台"><a href="#简述Android中的加固和使用平台" class="headerlink" title="简述Android中的加固和使用平台?"></a>简述Android中的加固和使用平台?</h4><p>加固:防止代码反编译,提高代码安全性.</p><p>加固三方平台,梆梆安全,360加固,爱加密等</p><p>区别:梆梆安全,360加固看不到项目中的类,爱加密看的到Java类,但是看不到里面的方法实现体,效果比前面差一点点。</p><p>加固的底层原理:第三方加固的应用会生成一个Apk,然后把你的APK读取出来,封装到这个第三方应用的APK里面.</p><h4 id="如何对APK瘦身"><a href="#如何对APK瘦身" class="headerlink" title="如何对APK瘦身?"></a>如何对APK瘦身?</h4><ul><li>使用混淆,</li><li>开启shrinkResourse(shrink-收缩),会将没有用到的图片变成一个像素点</li><li>删除无用的语言资源(删除国际化文件)</li><li>对于非透明的大图,使用JPG(没有透明度信息),代替PNG格式</li><li>使用tinypng进行图片压缩</li><li>使用webp图片格式,进一步压缩图片资源</li><li>使用第三方包时把用到的代码加到项目中来,避免引用整一个第三方库</li></ul><h4 id="简述多渠道打包及原理和常用操作"><a href="#简述多渠道打包及原理和常用操作" class="headerlink" title="简述多渠道打包及原理和常用操作?"></a>简述多渠道打包及原理和常用操作?</h4><p>针对每一个渠道(应用市场)都生成一个带有渠道标识的apk文件.</p><p>原理:用户下载启动应用,获取渠道标识,和设备的唯一标识,并上传到服务器里面,服务器根据获取的记录,根据渠道号然后判断是否存在该服务器的表里面.(打标记,取标记,上传标记)</p><ul><li>友盟多渠道打包:在清单文件中定义一个占位符,在gradle脚本中替换占位符(会使用到Python)</li><li>美团打包,在meta-data中创建一个空的文件,以文件名标识渠道,做一个解压与压缩的操作,速度会比较快</li><li>新一代多渠道打包,将渠道标识添加到.apk文件的末尾,并不会对源文件损坏</li></ul><h4 id="OkHttp相关"><a href="#OkHttp相关" class="headerlink" title="OkHttp相关?"></a>OkHttp相关?</h4><p>OkHttp支持同步和异步数据请求，但异步请求是在子线程 (因为原生OkHttp的使用时回调方法是在子线程进行的，要刷新界面还需要用Handler作处理，可以使用第三方的okhttp-utils,Okgo等等)；</p><p>OkHttp里面封装了线程池、数据转换、GZIP压缩（减少流量的传输）、HTTP协议缓存等,<br>OKHttp优点—使用GZip压缩减少传输的数据量,缓存(减少重复请求);</p><p>失败重试(如果你的服务有多个IP地址,如果第一次连接失败,OKHttp将使用备用地址)</p><p>OKhttp是对http协议的封装,比较底层,因此拓展性强,便于封装;对于https协议的支持需要处理一下：<a href="https://www.jianshu.com/p/f2097616e65e" target="_blank" rel="noopener">戳这里查看详情</a></p><p>OKhttp基于NIO(JDK1.5,非阻塞式IO)效率更高</p><h4 id="ButterKnife相关"><a href="#ButterKnife相关" class="headerlink" title="ButterKnife相关?"></a>ButterKnife相关?</h4><p>一款快速高效的注入框架，节约开发时间减少代码量（依靠插件动态生成View,点击事件等等）</p><p>优点：<br>1.强大的View绑定和Click事件处理功能，简化代码，提升开发效率<br>2.方便的处理Adapter里的ViewHolder绑定问题<br>3.运行时不会影响APP效率，使用配置方便<br>4.代码清晰，可读性强</p><p>使用经验：<br>1.Activity ButterKnife.bind(this);必须在setContentView();之后，且父类bind绑定后，子类不需要再bind</p><p>2.Fragment ButterKnife.bind(this, mRootView);</p><p>3.属性布局不能用private or static 修饰，否则会报错，（注意权限）</p><p>4.setContentView()不能通过注解实现。（其他的有些注解框架可以）</p><p>原理：利用注解和反射去获取绑定ViewID.</p><h4 id="Rxjava概念-常用操作符及拓展"><a href="#Rxjava概念-常用操作符及拓展" class="headerlink" title="Rxjava概念,常用操作符及拓展?"></a>Rxjava概念,常用操作符及拓展?</h4><p>一款优雅的异步框架,代替之前的AsyncTask / Handler / XXX / … </p><p>其强大的操作符和链式写法,线程切换等有助于提高开发效率和快速定位Bug</p><p>与Retrofit搭配使用更是有意想不到的效果，</p><p>缺点：<br>1：操作符太多会增加学习成本时间<br>2：使用不好，容易导致内存泄露(解决方式，推荐Rxlifecycle结合Rxjava，规避内存泄漏风险)</p><h4 id="Android中那些场景是执行在主线程的"><a href="#Android中那些场景是执行在主线程的" class="headerlink" title="Android中那些场景是执行在主线程的?"></a>Android中那些场景是执行在主线程的?</h4><ul><li>Activity生命周期回调都是执行在主线程的.</li><li>Service默认是执行在主线程的.</li><li>BroadcastReceiver的onReceive回调是执行在主线程的.</li><li>没有使用子线程的looper的Handler的handleMessage, post(Runnable)是执行在主线程的.</li><li>AsyncTask的回调中除了doInBackground, 其他都是执行在主线程的.</li><li>View的post(Runnable)是执行在主线程的.</li></ul><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存:"></a>三级缓存:</h4><p>当我们第一次打开应用获取图片或其它资源时，首先到网络去下载，然后依次存入内存缓存，磁盘缓存，</p><p>当我们再一次需要用到刚才下载的这张图片时，就不需要再重复的到网络上去下载，直接可以从内存缓存和磁盘缓存中找，由于内存缓存速度较快，我们优先到内存缓存中寻找该图片，如果找到则运用，</p><p>如果没有找到（内存缓存大小有限），那么我们再到磁盘缓存中去找。</p><p>只要我们合理的去协调这三层缓存运用，便可以提升应用性能,给用户更好的体验</p><p>三级缓存指的是：内存缓存、本地缓存、网络缓存。其各自的特点是内存缓存速度快, 优先读取，本地缓存速度其次, 内存没有该资源信息就去读取本地内存，网络缓存速度较慢(比较对象是内存缓存和本地缓存),假设本地内存也没有,才请求网络获取。</p><h4 id="Android中的四大组件相关"><a href="#Android中的四大组件相关" class="headerlink" title="Android中的四大组件相关?"></a>Android中的四大组件相关?</h4><p><strong>Activity:</strong><br>Activity是一个应用程序组件，提供一个屏幕(狭义的理解就是当前APP的界面)，用户可以用来交互为了完成某项任务。(点击,登录,跳转页面)<br>Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件(设置布局文件)。<br>在一个android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。</p><p><strong>Activity四种启动模式?</strong></p><p>Activity的启动模式指,可以根据实际开发需求为Activity设置对应的启动模式，从而可以避免创建大量重复的Activity等问题。</p><ul><li>standard<br>standard为Activity的默认启动模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。(点back键会依照栈顺序依次退出)</li><li>singleTop<br>singleTop模式下,Activity可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。</li><li>singleTask<br>singleTask表示只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。</li><li>singleInstance<br>只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。</li></ul><p><strong>BraodcastReceiver:</strong></p><p>使用了设计模式中的观察者模式：基于消息的发布/订阅事件模型。<br>注册的方式分为两种：静态注册、动态注册</p><p><strong>ContentProvider:</strong><br>外界可以通过ContentResolver接口来访问ContentProvider(内容提供者)中的数据。Uri 通用资源标志符（Universal Resource Identifier）Uri代表要操作的数据，Android中可用的每种资源 - 图像、视频片段等都可以用Uri来表示。ContentProvider共享数据是通过定义一个对外开放的统一的接口来实现的。然而，应用程序并不直接调用这些方法，而是使用一个 ContentResolver 对象，调用它的方法作为替代。ContentResolver可以与任意内容提供者进行会话，与其合作来对所有相关交互通讯进行管理。当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver类来完成，要获取ContentResolver对象，可以使用Context提供的getContentResolver()方法。</p><p><strong>IntentService：</strong><br>IntentService是Service的子类，比普通的Service增加了额外的功能。IntentService会创建独立的worker线程来处理所有的Intent请求；会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程的问题；所有请求处理完成后，IntentService会自动停止，开发者无需手动调用stopSelf()方法停止Service；</p><h4 id="简述System-exit-0-、onDestory-、Activity-finish-三者的区别"><a href="#简述System-exit-0-、onDestory-、Activity-finish-三者的区别" class="headerlink" title="简述System.exit(0) 、onDestory()、Activity.finish()三者的区别"></a>简述System.exit(0) 、onDestory()、Activity.finish()三者的区别</h4><ul><li>System.exit(0) 是你正常结束程序,kill 掉当前进程,针对的是整个Application</li><li>onDestory()方法是Activity生命周期的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法.</li><li>Activity.finish()当你调用此方法的时候，系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory（）方法，<strong>也就是占用的资源没有被及时释放。</strong></li></ul><h4 id="图片优化，以及图片加载框架的使用，如Picasso、-Fresco、Glide等？"><a href="#图片优化，以及图片加载框架的使用，如Picasso、-Fresco、Glide等？" class="headerlink" title="图片优化，以及图片加载框架的使用，如Picasso、 Fresco、Glide等？"></a>图片优化，以及图片加载框架的使用，如Picasso、 Fresco、Glide等？</h4><ul><li>尽量使用小的图片,对图片进行压缩，bitmapfactory.options图片配置类，insimplesize进行缩放，设置图片的编码方式；对图片使用软引用，内存不够时即时释图片内存；对图片的复用，三级缓存的使用；<br><strong>及时回收不再使用的bitmap对象；</strong></li><li>Picasso,不支持gif，缓存的是Argb8888的原图，占用内存较大,图片的框架使用了OkHttp缓存机制,使用Http协议缓存,也是异步加载.</li><li>Fresco,框架是FaceBook公司推出的,适合批量加载图片,底层是通过三级缓存(2级内存,1级磁盘),加载成功后自动替换成目标图片; </li><li>glide,Google公司14年推出来的,可以加载GIF图,也可以根据指定图片清晰度,底层的原理:为Bitmap维护一个对象池,对象池的目的是通过减少对象的分配,以重用来提高性能.对象池也可以帮助提高滚动的性能。API简洁易调用</li></ul><h4 id="Handle相关"><a href="#Handle相关" class="headerlink" title="Handle相关:"></a>Handle相关:</h4><p>Handler 工作流程基本包括 Handler、Looper、Message、MessageQueue 四个部分。但我们在日常开发中，经常都只会用到 Handler 和 Message 两个类。Message 负责消息的搭载，里面有个target用于标记消息，obj用于存放内容，Handler 负责消息的分发和处理。</p><h4 id="一般在开发中是怎么使用-Handler-的？"><a href="#一般在开发中是怎么使用-Handler-的？" class="headerlink" title="一般在开发中是怎么使用 Handler 的？"></a>一般在开发中是怎么使用 Handler 的？</h4><p>官方不允许在子线程中更新 UI，所以我们经常会把需要更新 UI 的消息直接发给处理器 Handler，通过重写 Handler 的handleMessage()方法进行 UI 的相关操作。<br><strong>Handle使用中需要注意？</strong><br>Handler 如果设置为私有变量的话，Android Studio 会报警告，提示可能会造成内存泄漏，这种情况可以通过设置为静态内部类 + 弱引用，或者在onDestroy()方法中调用Handler.removeCallbacksAndMessages(null)即可避免<br>Handler 整体工作流程浅析分为以下四个步骤：<br><strong>异步通信准备 =&gt; 消息入队 =&gt; 消息循环 =&gt; 消息处理</strong></p><ul><li>A：异步通信准备</li></ul><p>I：假定是在主线程创建 Handler，则会直接在主线程中创建处理器对象Looper、消息队列对象MessageQueue和 Handler 对象。</p><p>需要注意的是，Looper和MessageQueue均是属于其创建线程的。</p><p>II：Looper对象的创建一般通过Looper.prepareMainLooper()和Looper.prepare()两个方法，而创建Looper对象的同时，将会自动创建MessageQueue。</p><p>III：创建好MessageQueue后，Looper将自动进入消息循环。此时，Handler自动绑定了主线程的Looper和MessageQueue。</p><ul><li>B：消息入队</li></ul><p>工作线程通过Handler发送消息Message到消息队列MessageQueue中，消息内容一般是 UI 操作。发送消息一般都是通过Handler.sendMessage(Message msg)和Handler.post(Runnabe r)两个方法来进行的。而入队一般是通过MessageQueue.enqueueeMessage(Message msg,long when)来处理。</p><ul><li><p>C：消息循环<br>主要分为「消息出队」和「消息分发」两个步骤，Looper会通过循环取出消息队列MessageQueue里面的消息Message，并分发到创建该消息的处理者Handler。如果消息循环过程中，消息队列MessageQueue为空队列的话，则线程阻塞。</p></li><li><p>D：消息处理<br>Handler接收到Looper发来的消息，开始进行处理。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓,温故而知新，可以为师矣！这段时间到处面试，结合工作和网上一些文章，深感学有涯而知无涯~&lt;br&gt;在这里梳理一下，供学习思考。本篇主要是 native开发涉及到的Java知识点和Android方面知识。&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="interview" scheme="https://github.com/DJoeyZhang/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+NexT.Mist搭建主题blog，并分流托管至GitHub/Coding pages</title>
    <link href="https://github.com/DJoeyZhang/archives/22554.html"/>
    <id>https://github.com/DJoeyZhang/archives/22554.html</id>
    <published>2018-12-26T09:50:00.000Z</published>
    <updated>2019-01-14T09:26:13.496Z</updated>
    
    <content type="html"><![CDATA[<h4 id="序言：工作几年，从copy-amp-use的小萌新慢慢成长为design-amp-optimize-的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。"><a href="#序言：工作几年，从copy-amp-use的小萌新慢慢成长为design-amp-optimize-的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。" class="headerlink" title="序言：工作几年，从copy &amp; use的小萌新慢慢成长为design &amp; optimize 的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。"></a>序言：工作几年，从copy &amp; use的小萌新慢慢成长为design &amp; optimize 的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。</h4><hr><a id="more"></a><h4 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h4><p><a href="https://nodejs.org/download/" target="_blank" rel="noopener">下载Node.js</a><br><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">安装Node.js</a><br><a href="http://git-scm.com/download/" target="_blank" rel="noopener">下载安装Git</a></p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo:"></a>安装Hexo:</h4><p>在目标分区新建blog文件夹，使用hexo init 新建hexo文件夹，cd 到相应目录下，npm install安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd d:/hexo</span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo g # 或者hexo generate</span><br><span class="line">$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看</span><br></pre></td></tr></table></figure></p><h4 id="Hexo主题设置"><a href="#Hexo主题设置" class="headerlink" title="Hexo主题设置:"></a>Hexo主题设置:</h4><p><strong> 安装主题: </strong><br>从GitHub clone NexT theme到本地themes/next下，<a href="https://github.com/iissnan/hexo-theme-next">NexT地址</a><br><code>cd hexo/blog</code><br><code>$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br><strong>启用主题: </strong><br>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为next。<br><strong>更新主题: </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd themes/next</span><br><span class="line">$ git pull</span><br><span class="line">$ hexo g # 生成</span><br><span class="line">$ hexo s # 启动本地web服务器</span><br></pre></td></tr></table></figure></p><p>现在打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，会看到我们已经应用了一个新的主题。</p><h4 id="Github-Pages-Coding-Pages设置"><a href="#Github-Pages-Coding-Pages设置" class="headerlink" title="Github Pages/Coding Pages设置:"></a>Github Pages/Coding Pages设置:</h4><p>这里使用了GitHub pages和Coding pages双托管，实现国内外访问分流访问，国外访客访问域名跳转至GitHub pages 国内跳转 Coding pages，以达到分流提速的目的（由于众所周知的问题：国内访问GitHub.io速度较慢）</p><p><strong>Github Pages:</strong><br>github提供blog page服务，每个帐号只能有一个仓库来存放个人主页，仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> 来访问你的个人主页。<br>这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。<br>具体参考：<a href="https://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">简明Github Pages与Hexo教程</a></p><p>读到这里我们了解到：</p><ul><li>之前步骤中在Github上创建的那个特别的repo（username.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接<a href="http://username.github.io来直接访问。" target="_blank" rel="noopener">http://username.github.io来直接访问。</a></li><li>Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。</li><li>需要将hexo生成的静态网站，提交(git commit)到github上。</li></ul><p>注意：在使用hexo d命令自动部署时会自动删除CNAME文件。解决方法：用来指明域名的CNAME文件存放在blog/source目录下。</p><p><strong>Coding Pages:</strong><br>Coding pages的配置和GitHub pages上的配置方式大同小异，这里不赘述。需要指出的是：不建议把Coding账号免费升级到腾讯云平台。</p><p><strong> 使用hexo deploy一键部署双平台:</strong><br><a href="http://www.cnblogs.com/tengj/p/5352572.html" target="_blank" rel="noopener">参考这里配置</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h4><ul><li><a href="https://github.com/jaredly/hexo-admin">使用hexo-admin后台管理编辑发布你的blog</a></li><li><a href="http://lazyboy.site/hexo-admin-qiniu/2017/02/08/qiniu.html" target="_blank" rel="noopener">搭配hexo-admin使用七牛云图床（方便blog后期迁移）</a></li><li><a href="http://www.dajipai.cc/archives/ec8af0f7.html" target="_blank" rel="noopener">SEO优化/URL优化</a></li><li><a href="https://www.qq.com/404/" target="_blank" rel="noopener">腾讯公益404</a><br>注意：直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。</li><li><a href="https://blog.csdn.net/wsmrzx/article/details/81478945" target="_blank" rel="noopener">hexo blog使用的markdown常用语法</a></li><li><p>添加about页面:<br><code>$ hexo new page &quot;about&quot;</code><br>之后在sourceaboutindex.md目录下会生成一个index.md文件，打开输入个人信息即可，如果想要添加版权信息，可以在文件末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;font-size:12px;border-bottom: #ddd 1px solid; BORDER-LEFT: #ddd 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #ddd 1px solid; BORDER-RIGHT: #ddd 1px solid&quot;&gt;</span><br><span class="line">&lt;div style=&quot;MARGIN-TOP: 10px; FLOAT: left; MARGIN-LEFT: 5px; MARGIN-RIGHT: 10px&quot;&gt;</span><br><span class="line">&lt;IMG alt=&quot;&quot; src=&quot;https://avatars1.githubusercontent.com/u/168751?v=3&amp;s=140&quot; width=90 height=100&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;LINE-HEIGHT: 200%; MARGIN-TOP: 10px; COLOR: #000000&quot;&gt;</span><br><span class="line">本文链接：&lt;a href=&quot;&lt;%= post.link %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;br/&gt;</span><br><span class="line">作者： </span><br><span class="line">&lt;a href=&quot;http://jiji262.github.io/&quot;&gt;&#123;username&#125;&lt;/a&gt; &lt;br/&gt;出处： </span><br><span class="line">&lt;a href=&quot;http://jiji262.github.io/&quot;&gt;https://jacofaker.cn/&lt;/a&gt;</span><br><span class="line">&lt;br/&gt;本文基于&lt;a target=&quot;_blank&quot; title=&quot;Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt; 知识共享署名-相同方式共享 4.0 &lt;/a&gt;</span><br><span class="line">国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名 </span><br><span class="line">&lt;a href=&quot;https://jacofaker.cn&quot;&gt;author&lt;/a&gt;及链接。</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加支付宝捐赠按钮及二维码支付:<br><strong>支付宝捐赠按钮:</strong><br>在hexo/themes/next/layout_widget目录下新建一个zhifubao.ejs文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;asidetitle&quot;&gt;打赏他&lt;/p&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;form action=&quot;https://xxx.alipay.com/send/payment/fill.htm&quot; method=&quot;POST&quot; target=&quot;_blank&quot; accept-charset=&quot;GBK&quot;&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;input name=&quot;optEmail&quot; type=&quot;hidden&quot; value=&quot;your 支付宝账号&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;payAmount&quot; type=&quot;hidden&quot; value=&quot;默认捐赠金额(元)&quot; /&gt;</span><br><span class="line">    &lt;input id=&quot;title&quot; name=&quot;title&quot; type=&quot;hidden&quot; value=&quot;博主，打赏你的！&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;memo&quot; type=&quot;hidden&quot; value=&quot;你Y加油，继续写博客！&quot; /&gt;</span><br><span class="line">    &lt;input name=&quot;pay&quot; type=&quot;image&quot; value=&quot;转账&quot; src=&quot;http://7xig3q.com1.z0.glb.clouddn.com/alipay-donate-website.png&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>添加完该文件之后，要在hexo/themes/next/_config.yml文件中启用，如下所示，添加zhifubao:</p><p>widgets:<br> -category<br> -tag<br> -links<br> -tagcloud<br> -zhifubao<br> -rss</p><p><strong>二维码捐赠:</strong></p><p>首先需要到<a href="https://qr.alipay.com/paipai/open.htm" target="_blank" rel="noopener">这里</a>获取你的支付宝账户的二维码图片，支付宝提供了自定义功能，可以添加自定义文字。</p><p>我的二维码扫描捐赠添加在about页面，当然你也可以添加到其它页面，在hexo/blog/source/about下有index.md，打开，在适当位置添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">欢迎您捐赠本站，您的支持是我最大的动力！</span><br><span class="line">![][http://7xsxyo.com1.z0.glb.clouddn.com/2016/04/15/FoJ1F6Ht0CNaYuCdE2l52F-Fk9Vk202.png]</span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;center&gt;可以让图片居中显示，注意将图片链接地址换成你的即可。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;序言：工作几年，从copy-amp-use的小萌新慢慢成长为design-amp-optimize-的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。&quot;&gt;&lt;a href=&quot;#序言：工作几年，从copy-amp-use的小萌新慢慢成长为design-amp-optimize-的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。&quot; class=&quot;headerlink&quot; title=&quot;序言：工作几年，从copy &amp;amp; use的小萌新慢慢成长为design &amp;amp; optimize 的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。&quot;&gt;&lt;/a&gt;序言：工作几年，从copy &amp;amp; use的小萌新慢慢成长为design &amp;amp; optimize 的大萌新。希望找个地方记录自己的工作生活。那我们先从如何折腾这个blog空间开始。&lt;/h4&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="other" scheme="https://github.com/DJoeyZhang/tags/other/"/>
    
  </entry>
  
</feed>
