<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>权译&#39;s  Blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DJoeyZhang/"/>
  <updated>2020-01-15T06:58:45.719Z</updated>
  <id>https://github.com/DJoeyZhang/</id>
  
  <author>
    <name>权译</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MarkDown常用语法总结</title>
    <link href="https://github.com/DJoeyZhang/archives/ab9e4bfe.html"/>
    <id>https://github.com/DJoeyZhang/archives/ab9e4bfe.html</id>
    <published>2020-01-15T06:02:00.000Z</published>
    <updated>2020-01-15T06:58:45.719Z</updated>
    
    <content type="html"><![CDATA[<h5 id="工欲善其事，必先利其器。记录一下常用的MD语法"><a href="#工欲善其事，必先利其器。记录一下常用的MD语法" class="headerlink" title="工欲善其事，必先利其器。记录一下常用的MD语法"></a>工欲善其事，必先利其器。记录一下常用的MD语法</h5><a id="more"></a><h5 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题<br></h5><p>一个#表示一级标题，最多6个表示6级标题</p><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><h6 id="h6"><a href="#h6" class="headerlink" title="h6"></a>h6</h6><h5 id="2、列表"><a href="#2、列表" class="headerlink" title="2、列表"></a>2、列表<br></h5><p>无序列表，用 * + - 都可以表示,【可以用四个空格来分级】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 列表</span><br><span class="line">    + 次级</span><br><span class="line">    - 次级</span><br><span class="line">* 列表</span><br></pre></td></tr></table></figure></p><p>效果如下<br></p><ul><li>列表<ul><li>次级</li></ul><ul><li>次级</li></ul></li><li>列表</li></ul><h5 id="3、分割线"><a href="#3、分割线" class="headerlink" title="3、分割线"></a>3、分割线<br></h5><p>用三个 - 或 _ 表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure></p><p>效果如下<br></p><hr><hr><h5 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接<br></h5><p>链接文字放到中括号[]里，链接地址放到小括号里，<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">比如：[链接文字](http://baidu.com) </span><br><span class="line">比如：&lt;http://baidu.com&gt; </span><br><span class="line">[谷歌][1]，[雅虎][2]，[微软][3]</span><br><span class="line">[1]: http://google.com/ &quot;google&quot;</span><br><span class="line">[2]: http://yahoo.com/ &quot;yahoo&quot;</span><br><span class="line">[3]: http://msn.com/ &quot;msn&quot;</span><br></pre></td></tr></table></figure></p><p>效果如下<br><br>比如：<a href="http://baidu.com" target="_blank" rel="noopener">链接文字</a><br>比如：<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a><br>[谷歌][1]，[雅虎][2]，[微软][3]<br>[1]: <a href="http://google.com/" target="_blank" rel="noopener">http://google.com/</a> “google”<br>[2]: <a href="http://yahoo.com/" target="_blank" rel="noopener">http://yahoo.com/</a> “yahoo”<br>[3]: <a href="http://msn.com/" target="_blank" rel="noopener">http://msn.com/</a> “msn”</p><h5 id="5、图片"><a href="#5、图片" class="headerlink" title="5、图片"></a>5、图片<br></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![百度](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1579079569938&amp;di=6d83e30e6900484e114b728c02c509d4&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1971315160%2C3100712330%26fm%3D214%26gp%3D0.jpg)</span><br></pre></td></tr></table></figure><p>效果如下：<img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1579079569938&amp;di=6d83e30e6900484e114b728c02c509d4&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1971315160%2C3100712330%26fm%3D214%26gp%3D0.jpg" alt="百度"><br><br></p><h5 id="6、代码框"><a href="#6、代码框" class="headerlink" title="6、代码框"></a>6、代码框<br></h5><p>开头结尾用`，单行用一个`，多行用三个```<br>单行：开头结尾用一个反引号`</p><p><code>console.log(&#39;talk is cheap, show me the code&#39;)</code></p><p>console.log(‘talk is cheap, show me the code’)</p><p>多行：开头与结尾分别用三个反引号```<br>单独占一行,可指定或不指定语言，比如javascript<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> skills)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'wanderful skill: '</span> + skills[I]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h5 id="7、强调"><a href="#7、强调" class="headerlink" title="7、强调"></a>7、强调<br></h5><p>开头结尾用*(或者_)，*表示斜体，**表示加粗，***表示斜体加粗</p><p><em>em</em><br><br><strong>strong</strong><br><br><strong><em>斜体加粗</em></strong><br></p><h5 id="8、删除线"><a href="#8、删除线" class="headerlink" title="8、删除线"></a>8、删除线<br></h5><p>开头结尾用~~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~待删除~~</span><br></pre></td></tr></table></figure></p><p><del>待删除</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;工欲善其事，必先利其器。记录一下常用的MD语法&quot;&gt;&lt;a href=&quot;#工欲善其事，必先利其器。记录一下常用的MD语法&quot; class=&quot;headerlink&quot; title=&quot;工欲善其事，必先利其器。记录一下常用的MD语法&quot;&gt;&lt;/a&gt;工欲善其事，必先利其器。记录一下常用的MD语法&lt;/h5&gt;
    
    </summary>
    
    
      <category term="tools" scheme="https://github.com/DJoeyZhang/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>移动开发者音视频知识扫盲</title>
    <link href="https://github.com/DJoeyZhang/archives/6b71779b.html"/>
    <id>https://github.com/DJoeyZhang/archives/6b71779b.html</id>
    <published>2020-01-14T09:33:02.000Z</published>
    <updated>2020-01-14T10:12:56.316Z</updated>
    
    <content type="html"><![CDATA[<h5 id="工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。"><a href="#工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。" class="headerlink" title="工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。"></a>工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。<br></h5><p>先上两个经典的音视频项目地址，供参考研究：<br><br>ijkPlayer:<a href="https://github.com/bilibili/ijkplayer">https://github.com/bilibili/ijkplayer</a> <br><br>GSYVideoPlayer:<a href="https://github.com/CarGuo/GSYVideoPlayer">https://github.com/CarGuo/GSYVideoPlayer</a><br><a id="more"></a></p><h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>首先，如下图所示是一个 .MOV 的视频文件，可以看到更多信息栏里编码器有 AAC 、HEVC ，而这个就是视频的音频编码和视频编码，而 MOV 其实就是封装协议，这其实就是我们接下来要介绍的基本概念。<br><img src="../images/WechatIMG341.png" alt=""></p><p>一般情况下，视频流从加载都准备播放是需要经过解协议、解封装、解编码这样的过程，其中协议指的就是流媒体协议；封装是的是视频的封装格式；编码又分为视频编码和音频编码。<br><br>协议一般有 HTTP 、RTSP、RTMP 等，我们就最常见的就是 HTTP 网络协议，而 RTSP 和 RTMP 一般用于直播流或支持带有控制信令的常见，比如远程监控。<br><br>视频封装协议指的是我们常见的 MP4 、AVI 、RMVB 、MKV、TS、FLV 等常见后缀格式，它们所表示的就是多媒体的封装协议，就是在传输过程中把音频和视频打包都一起的封装，所以播放前是需要把这部分内容解开，提取出对应音频编码和视频编码。</p><p>所以如果以后有人问你，你是视频编码是什么，专业的你不能再回答 “我的视频编码是 MP4” 这样的回复哟。</p><h5 id="1、音频编码"><a href="#1、音频编码" class="headerlink" title="1、音频编码"></a>1、音频编码</h5><p>音频编码指的是音频数据的编码方式，常见的如：MP3、 PCM、WAV、AAC、AC-3 等，因为音频的原始数据大小一般不适合直接传入，比如原始大小一般可以按照采样率 <em> 声道数 </em> 样本格式 去计算，假设前面那个 MOV 的音频采样率是 44100 、样本格式是 16 bit 、单声道、24 秒，那么它原始音频大小应该是<br><br><code>44100 * 16 * 1 * 24 / 8 ≈ 2MB</code><br><br><br>而实际将音频信息提取出来的大小，如下图大概只有 200 多K，这就是音频编码的作用。</p><p><img src="../images/WechatIMG343.png" alt=""></p><p>所以一般都会音频传输会采用各种编码格式进行压缩和去冗余，其中比如 WAV/PCM 编码的音频质量比较好，但是体积会比较大；MP3 有损压缩能在音频质量还可以的情况下压缩音频的体积；AAC 也是有损压缩，但是又有分有 LC-AAC、HE-AAC等。</p><h5 id="2、视频编码"><a href="#2、视频编码" class="headerlink" title="2、视频编码"></a>2、视频编码</h5><p>视频编码指的就是画面图像的编码压缩方式，一般有 H263、H264、HEVC（H265）、MPEG-2 、MPEG-4 等，其中H264 是目前比较常见的编码方式。<br><br>通常情况下我们理解的画面是 RGB 组合出来，而目前视频领域可能更多使用 YUV 格式，其中 Y 表示的是亮度（灰度），而 U 和 V表示的是色度（饱和度）。<br><br>YUV 是对 RGB 的特殊处理和叠加来获取颜色，比如 YUV420 可以理解对色度以 2：1 的抽样率进行存储，然后亮度透过色度来显示画面，更多 YUV 的这里就不展开讨论，而为什么使用 YUV 其中有一点因素就是为了兼容以前的黑白电视。<br><br>为什么不直接用原始 YUV ？这里假设上面的 MOV 视频直接使用 YUV420 的格式，那么一帧的大小就会是：<br><br><code>1080 * 1920 * 1 + 1080 * 1920 * 0.5 = 2.9MB</code><br><br><br>如果在这个基础上，算上帧率（30）和一个视频的时长（一小时），那一部视频原始大小就会是天文数字，这样的情况明显不符合网络传输，所以才有了视频编码用于压缩图像。<br><br>在视频压缩里，又有几个概念需要知道，比如：</p><ul><li>IPB 帧是一种常见的帧压缩方法，其中 I 帧属于关键帧是每个画面的参考帧； P 帧是前向预测帧；B 帧是双向预测帧。简单来说就是 I 帧自己就可以得到一个完整画面，而 P 帧需要前面的 I 帧或者 P 帧来帮助解码得到一个完整画面，而 B 帧则需要前面的 I/P 帧或者后面的 P 帧来协助形成一个画面。</li></ul><ul><li>所以 I 帧是很关键的存在，压缩 I 帧就可以很容易压制掉空间的大小，而压缩 P/B 帧可以压缩掉时间上的冗余信息 。所以在视频 seek 的时候，I 帧很关键，如果视频 seek 之后发生往前的跳动，那很可能就是你的视频压缩得太厉害了。</li></ul><ul><li>还有一个叫 IDR 帧的概念，因为 H264 采用的是多帧预测，导致 I 帧不能作为独立的观察条件，所以多出一个叫  IDR 帧的特殊 I 帧用于参考，IDR 帧最关键的概念就是：在解码器过程中一旦收到 IDR 帧，就会立即清空参考帧缓冲区，并将IDR帧作为被参考帧。</li></ul><ul><li><p>在视频解码里还有一个叫 DTS（Decoding Time Stamp） 和 PTS（Presentation Time Stamp）的存在，DTS主要用于视频的解码，PTS主要用于在解码阶段对视频进行同步和输出。因为视频包里面数据解码不是连续的，而是需要通过解码数据源得到的 DTS，才 决定以包应该在什么时候被解码，而得到的PTS 决定了解码后的图片什么时候被绘制。</p></li><li><p>GOP（Group Of Picture）就是两个 I 帧之间的距离，一般 GOP 设置得越大，画面的效果就会越好，到那时需要解码的时间就会越长。 所以如果码率固定而 GOP 值越大，P/B帧 数量会越多，画面质量就会越高。</p></li></ul><h4 id="二、Q-amp-A"><a href="#二、Q-amp-A" class="headerlink" title="二、Q&amp;A"></a>二、Q&amp;A</h4><p>首先说一个经常被问的问题：ffmpeg 全称是 Fast Forward Mpeg ，所以读法为 (ef,ef,’em,peg) ，一般情况下 ffmpeg 使用的是软解码，也即是纯 CPU 解码；而使用平台的 MediaCodec 播放的是硬解码，也就是支持 GPU 协助。<br></p><p>问题1:“为什么同一个视频机器A可以播机器B不可以？”<br><br>这个问题很大可能就是使用了 MediaCodec 的硬解码播放，不同手机和系统版本，对于硬解码的支持是不一样的。<br><br>问题2:“为什么都是 ffmpeg 播放，vlc 可以播放，ijkplayer 却不行？”<br><br>这是因为 ffmpeg 是支持根据配置打包的，因为很多时候你并不需要那么多，比如在 configure 文件中打开和关闭某些格式的支持来达到按需打包的目的，所以同样是 ffmpeg 不同项目打包支持的程度可能都不同。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">支持wav</span><br><span class="line"></span><br><span class="line">    --enable-libwavpack</span><br><span class="line">    --enable-muxer=wav</span><br><span class="line">    --enable-demuxer=wav</span><br><span class="line">    --enable-decoder=wavpack</span><br><span class="line">    --enable-encoder=wavpack</span><br><span class="line">    --enable-decoder=wav</span><br><span class="line">    --enable-encoder=wav</span><br><span class="line">    --enable-encoder=pcm_s16le</span><br><span class="line">    --enable-decoder=pcm_s16le</span><br><span class="line"></span><br><span class="line">    --enable-encoder=pcm_u8</span><br><span class="line">    --enable-decoder=pcm_u8</span><br><span class="line">    --enable-muxer=pcm_u8</span><br><span class="line">    --enable-demuxer=pcm_u8  </span><br><span class="line">    </span><br><span class="line">支持mp2    </span><br><span class="line">    --enable-encoder=mp2 </span><br><span class="line">    --enable-decoder=mp2 </span><br><span class="line">    --enable-muxer=mp2 </span><br><span class="line">    --enable-decoder=mp2float </span><br><span class="line">    --enable-encoder=mp2fixed </span><br><span class="line">    </span><br><span class="line">支持 h265   </span><br><span class="line">    --enable-decoder=hevc</span><br></pre></td></tr></table></figure></p><p>复制代码问题3：“为什么我的视频缓冲了，在 seek 之后还需要重新请求？”<br><br>这就需要解释缓存和缓冲的区别：</p><p>缓冲：就像在倒垃圾的时候，不可能一有垃圾马上跑去垃圾堆倒，而是先把垃圾倒到垃圾桶，垃圾桶满了再一起倒到垃堆。因为缓冲是在内存中，不可在内存中把整个视频都缓冲进去，所以一般情况下你看到的缓冲都是一段一段的临时数据，一个缓冲块是处于不断地加载又不断清除的过程。</p><p>缓存: 缓存的解释就简单多了，就是把视频在播放的时候一边下载到本地，这样在缓存区域内的数据就不需要发生二次请求。</p><p>问题4：“为什么我的视频在拖拽之后会出现跳动？”<br><br>其实前面已经解释过了，这和视频的关键帧有关系，同时也和 ffmpeg 选择的兼容策略有关系，比如使用 -accurate_seek 可以让位于跳转点和 position 之间的额外部分将被解码并且丢弃，对应 ijk 中就是 enable-accurate-seek 的配置。<br></p><p>问题5：“为什么我的视频会出现音视频不同步？”<br><br>首选确定你的播放器使用的音视频同步协议是什么，比如 ijkplayer 是使用音频作为同步时钟，如果在 ijkplayer 里 在出现音视频不同步，那么很可能就是视频的码率或者帧率太高，可以尝试使用使用 framedrop 丢帧或者开启硬解码支持。<br></p><p>问题6：“为什么我的视频会出现大小和方向不对？”<br><br>一般情况下视频信息里是带有旋转角度的，比如 Android 手机上录制的视频就可能带有旋转角度，所以在布局和绘制时需要把旋转角度如： 270，90 这样的角度考虑上。<br>另外视频在获取大小还会有  Width Height Ratio 的信息也就是宽高比，例如这个信息在 ijkplayer 上是以 videoSarNum / videoSarDen 得到的，只有把宽高比和视频的宽高一起计算，才能获取到真正的展示宽高。<br></p><p>问题7：“为什么我的视频会出现黑边？”<br><br>这个问题其实就是常识性问题，面对不同尺寸不同分辨率的平台，视频显示是根据你给定的 Surface 大小去进行显示，所以你可以选择使用拉伸、裁剪、适应高度、适应宽度等不同布局模式去配置你的绘制控件，这样就可以达到你需要的控制黑边的场景。<br></p><p>诸如此类的问题还有 “如何获取某个时间戳的图像”、“如何同时播放几个视频”、“如何实现播放滤镜”、“如何实现倍速播放” 等问题，这里就不一一展开，感兴趣的可以去 GSYVideoPlayer 的 issue 或者搜索相关的 ffmpeg 实现。<br><br>使用场景<br><br>最后讲一下音视频开发的使用场景，为什么要说这个呢？<br>因为很多时候开发者可能以为“不就是接个播放器 SDK 放个 Url 的功夫吗？” 其实还真不是，做过音视频开发的应该都深有体会。</p><p>1、首先在做音视频开发时，要确定好自己需要支持的封装协议、视频编码、音频编码格式，因为编码格式千万种，一般情况下你不可能全都支持，所以首先要在需求内确定好需要支持的格式范围。</p><p>2、如果存在用户自主上传视频的场景，最好还要在服务端提供转格式与转码率等功能。因为在服务端判断视频格式并转码可以规范编码统一，这能够减少客户端端因为编解码失败无法播放的问题；另外提供同一视频不同码率的链接，可以在不同手机型号和系统上能够拥有更好的播放体验，减少前面说过的因为码率太高出现音视频不同步或者卡顿的问题。</p><p>3、在网络播放中存在很多场景，比如播放过程中网络环境出现变化，是从 4G 转化为 Wifi 还是从 Wifi 转到了 4G 的场景 ，这里面涉及到两个点：第一是网络环境发生改变，那么原本的拉流通道其实已经断开，这时候需要重新启动一个新的连接来替换旧的播放内核，才能实现继续播放；第二就是 Wifi 到 4G 之间的环境发生改变时，需要给用户提示并确定是否执行后续操作。</p><p>4、还有比如当视频画面需要从列表切换到详情页，需要从原本的容器切换到另外一个可渲染容器时，需要在播放内核不暂停的情况下去设置不同的 Surface 来达到切换的目的；片头广告的播放与视频内容的预加载需要两个不同的请求处理等等的场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。&quot;&gt;&lt;a href=&quot;#工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。&quot; class=&quot;headerlink&quot; title=&quot;工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。&quot;&gt;&lt;/a&gt;工作原因，接触到音视频开发，作为移动开发者，掌握必要的音视频概念是很必要的。此篇记录一些音视频开发中常用的术语，做一些简单的扫盲工作。&lt;br&gt;&lt;/h5&gt;&lt;p&gt;先上两个经典的音视频项目地址，供参考研究：&lt;br&gt;&lt;br&gt;ijkPlayer:&lt;a href=&quot;https://github.com/bilibili/ijkplayer&quot;&gt;https://github.com/bilibili/ijkplayer&lt;/a&gt; &lt;br&gt;&lt;br&gt;GSYVideoPlayer:&lt;a href=&quot;https://github.com/CarGuo/GSYVideoPlayer&quot;&gt;https://github.com/CarGuo/GSYVideoPlayer&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis中涉及到的一些设计模式</title>
    <link href="https://github.com/DJoeyZhang/archives/2387c9a6.html"/>
    <id>https://github.com/DJoeyZhang/archives/2387c9a6.html</id>
    <published>2020-01-14T02:14:00.000Z</published>
    <updated>2020-01-14T08:53:13.944Z</updated>
    
    <content type="html"><![CDATA[<h5 id="有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。"><a href="#有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。" class="headerlink" title="有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。"></a>有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。</h5><a id="more"></a><h5 id="虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。"><a href="#虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。" class="headerlink" title="虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。"></a>虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。</h5><h5 id="Mybatis至少应用了以下九种设计模式："><a href="#Mybatis至少应用了以下九种设计模式：" class="headerlink" title="Mybatis至少应用了以下九种设计模式："></a>Mybatis至少应用了以下九种设计模式：</h5><p>1、Builder模式；2、工厂模式；3、单例模式；4、代理模式；5、组合模式；6、模板方法模式；7、适配器模式；8、装饰者模式；9、迭代器模式；<br></p><h6 id="一、Builder模式"><a href="#一、Builder模式" class="headerlink" title="一、Builder模式:"></a>一、Builder模式:<br></h6><p>Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”<br><br>它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。<br><br>在Mybatis环境的初始化过程中，会做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。对于builder的具体类，方法都大都用build*开头，比如SqlSessionFactoryBuilder为例，它根据不同的输入参数来构建SqlSessionFactory这个工厂对象。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class SqlSessionFactoryBuilder &#123;</span><br><span class="line">  ...</span><br><span class="line">  //示例代码保留两个重要的build重载方法</span><br><span class="line">  public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      try &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        // Intentionally ignore. Prefer previous error.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      try &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        // Intentionally ignore. Prefer previous error.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式:"></a>二、工厂模式:<br></h6><p>在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。<br><br>在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">Transaction tx = null;</span><br><span class="line">try &#123;</span><br><span class="line">final Environment environment = configuration.getEnvironment();</span><br><span class="line">final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">final Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">closeTransaction(tx); // may have fetched a connection so lets call</span><br><span class="line">// close()</span><br><span class="line">throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">ErrorContext.instance().reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象，然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。而对于LogFactory，它的实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class LogFactory &#123;</span><br><span class="line">private static Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">private LogFactory() &#123;</span><br><span class="line">// disable construction</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Log getLog(Class&lt;?&gt; aClass) &#123;</span><br><span class="line">return getLog(aClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个特别的地方，是Log变量的的类型是Constructor&lt;? extends Log&gt;，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。<br></p><h6 id="三、单例模式-Singleton-Pattern-："><a href="#三、单例模式-Singleton-Pattern-：" class="headerlink" title="三、单例模式(Singleton Pattern)："></a>三、单例模式(Singleton Pattern)：</h6><p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。<br><br>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。<br><br>单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。在Mybatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而LogFactory则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。<br><br>ErrorContext的单例实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ErrorContext &#123;</span><br><span class="line"></span><br><span class="line">private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();</span><br><span class="line"></span><br><span class="line">private ErrorContext() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ErrorContext instance() &#123;</span><br><span class="line">ErrorContext context = LOCAL.get();</span><br><span class="line">if (context == null) &#123;</span><br><span class="line">context = new ErrorContext();</span><br><span class="line">LOCAL.set(context);</span><br><span class="line">&#125;</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。只是这里有个有趣的地方是，LOCAL的静态实例变量使用了ThreadLocal修饰，也就是说它属于每个线程各自的数据，而在instance()方法中，先获取本线程的该实例，如果没有就创建该线程独有的ErrorContext。</p><h6 id="四、代理模式"><a href="#四、代理模式" class="headerlink" title="四、代理模式:"></a>四、代理模式:<br></h6><p>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。代理模式包含如下角色：Subject: 抽象主题角色Proxy: 代理主题角色RealSubject: 真实主题角色这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务；当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">private final Class&lt;T&gt; mapperInterface;</span><br><span class="line">private final Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123;</span><br><span class="line">this.mapperInterface = mapperInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Class&lt;T&gt; getMapperInterface() &#123;</span><br><span class="line">return mapperInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123;</span><br><span class="line">return methodCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123;</span><br><span class="line">return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;,</span><br><span class="line">mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，先通过T newInstance(SqlSession sqlSession)方法会得到一个MapperProxy对象，然后调用T newInstance(MapperProxymapperProxy)生成代理对象然后返回。而查看MapperProxy的代码，可以看到如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">return method.invoke(this, args);</span><br><span class="line">&#125; else if (isDefaultMethod(method)) &#123;</span><br><span class="line">return invokeDefaultMethod(proxy, method, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line">throw ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">&#125;</span><br><span class="line">final MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">return mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>非常典型的，该MapperProxy类实现了InvocationHandler接口，并且实现了该接口的invoke方法。通过这种方式，我们只需要编写Mapper.java接口类，当真正执行一个Mapper接口的时候，就会转发给MapperProxy.invoke方法，而该方法则会调用后续的sqlSession.cud&gt;executor.execute&gt;prepareStatement等一系列方法，完成SQL的执行和返回。<br></p><h6 id="五、组合模式"><a href="#五、组合模式" class="headerlink" title="五、组合模式:"></a>五、组合模式:<br></h6><p>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。<br><br>同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。Mybatis支持动态SQL的强大功能，比如下面的这个SQL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;update&quot; parameterType=&quot;org.format.dynamicproxy.mybatis.bean.User&quot;&gt;</span><br><span class="line">    UPDATE users</span><br><span class="line">    &lt;trim prefix=&quot;SET&quot; prefixOverrides=&quot;,&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;name != null and name != &apos;&apos;&quot;&gt;</span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;age != null and age != &apos;&apos;&quot;&gt;</span><br><span class="line">            , age = #&#123;age&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;birthday != null and birthday != &apos;&apos;&quot;&gt;</span><br><span class="line">            , birthday = #&#123;birthday&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    where id = $&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></p><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；在DynamicSqlSource.getBoundSql方法里，调用了rootSqlNode.apply(context)方法，apply方法是所有的动态节点都实现的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SqlNode &#123;</span><br><span class="line">boolean apply(DynamicContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于实现该SqlSource接口的所有节点，就是整个组合模式树的各个节点：组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean apply(DynamicContext context) &#123;</span><br><span class="line">GenericTokenParser parser = createParser(new BindingTokenParser(context, injectionFilter));</span><br><span class="line">context.appendSql(parser.parse(text));</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是对于IfSqlNode，就需要先做判断，如果判断通过，仍然会调用子元素的SqlNode，即contents.apply方法，实现递归的解析。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean apply(DynamicContext context) &#123;</span><br><span class="line">if (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">contents.apply(context);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="六、模板方法模式"><a href="#六、模板方法模式" class="headerlink" title="六、模板方法模式:"></a>六、模板方法模式:<br></h6><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。<br><br>代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。<br><br>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，Executor包含以下结构：其中的BaseExecutor就采用了模板方法模式，它实现了大部分的SQL执行逻辑，然后把以下几个方法交给子类定制化完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;</span><br><span class="line"></span><br><span class="line">protected abstract List&lt;BatchResult&gt; doFlushStatements(boolean isRollback) throws SQLException;</span><br><span class="line"></span><br><span class="line">protected abstract &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds,</span><br><span class="line">ResultHandler resultHandler, BoundSql boundSql) throws SQLException;</span><br></pre></td></tr></table></figure></p><p>该模板方法类有几个子类的具体实现，使用了不同的策略：简单SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（可以是Statement或PrepareStatement对象）重用ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。（可以是Statement或PrepareStatement对象）批量BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）比如在SimpleExecutor中这样实现update方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">Statement stmt = null;</span><br><span class="line">try &#123;</span><br><span class="line">Configuration configuration = ms.getConfiguration();</span><br><span class="line">StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null,</span><br><span class="line">null);</span><br><span class="line">stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">return handler.update(stmt);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">closeStatement(stmt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="七、适配器模式适配器模式-Adapter-Pattern-："><a href="#七、适配器模式适配器模式-Adapter-Pattern-：" class="headerlink" title="七、适配器模式适配器模式(Adapter Pattern) ："></a>七、适配器模式适配器模式(Adapter Pattern) ：<br></h6><p>将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。在Mybatsi的logging包中，有一个Log接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface Log &#123;</span><br><span class="line"></span><br><span class="line">boolean isDebugEnabled();</span><br><span class="line"></span><br><span class="line">boolean isTraceEnabled();</span><br><span class="line"></span><br><span class="line">void error(String s, Throwable e);</span><br><span class="line"></span><br><span class="line">void error(String s);</span><br><span class="line"></span><br><span class="line">void debug(String s);</span><br><span class="line"></span><br><span class="line">void trace(String s);</span><br><span class="line"></span><br><span class="line">void warn(String s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配：比如对于Log4jImpl的实现来说，该实现持有了org.apache.log4j.Logger的实例，然后所有的日志方法，均委托该实例来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Log4jImpl implements Log &#123;</span><br><span class="line"></span><br><span class="line">private static final String FQCN = Log4jImpl.class.getName();</span><br><span class="line"></span><br><span class="line">private Logger log;</span><br><span class="line"></span><br><span class="line">public Log4jImpl(String clazz) &#123;</span><br><span class="line">log = Logger.getLogger(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isDebugEnabled() &#123;</span><br><span class="line">return log.isDebugEnabled();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isTraceEnabled() &#123;</span><br><span class="line">return log.isTraceEnabled();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void error(String s, Throwable e) &#123;</span><br><span class="line">log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void error(String s) &#123;</span><br><span class="line">log.log(FQCN, Level.ERROR, s, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void debug(String s) &#123;</span><br><span class="line">log.log(FQCN, Level.DEBUG, s, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void trace(String s) &#123;</span><br><span class="line">log.log(FQCN, Level.TRACE, s, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void warn(String s) &#123;</span><br><span class="line">log.log(FQCN, Level.WARN, s, null);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="八、装饰者模式装饰模式-Decorator-Pattern-："><a href="#八、装饰者模式装饰模式-Decorator-Pattern-：" class="headerlink" title="八、装饰者模式装饰模式(Decorator Pattern) ："></a>八、装饰者模式装饰模式(Decorator Pattern) ：<br></h6><p>动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。<br><br>在mybatis中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）永久缓存实现，然后通过一系列的装饰器来对PerpetualCache永久缓存进行缓存策略等方便的控制。用于装饰PerpetualCache的标准装饰器共有8个（全部在org.apache.ibatis.cache.decorators包中）：<br><br>1、FifoCache：先进先出算法，缓存回收策略<br><br>2、LoggingCache：输出缓存命中的日志信息<br><br>3、LruCache：最近最少使用算法，缓存回收策略<br><br>4、ScheduledCache：调度缓存，负责定时清空缓存<br><br>5、SerializedCache：缓存序列化和反序列化存储<br><br>6、SoftCache：基于软引用实现的缓存管理策略<br><br>7、SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问<br><br>8、WeakCache：基于弱引用实现的缓存管理策略另外，还有一个特殊的装饰器<br><br>9、TransactionalCache：事务性的缓存。<br><br>正如大多数持久层框架一样，mybatis缓存同样分为一级缓存和二级缓存一级缓存，又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中（BaseExecutor），而执行器又在SqlSession（DefaultSqlSession）中，所以一级缓存的生命周期与SqlSession是相同的。<br><br>二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在Configuration核心配置对象中。二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis会根据配置自动追加一系列装饰器。<br><br>Cache对象之间的引用顺序为：SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p><h6 id="九、迭代器模式迭代器（Iterator）模式，又叫做游标（Cursor）模式"><a href="#九、迭代器模式迭代器（Iterator）模式，又叫做游标（Cursor）模式" class="headerlink" title="九、迭代器模式迭代器（Iterator）模式，又叫做游标（Cursor）模式:"></a>九、迭代器模式迭代器（Iterator）模式，又叫做游标（Cursor）模式:<br></h6><p>GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。Java的Iterator就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式：比如Mybatis的PropertyTokenizer是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了Iterator接口，在使用时经常被用到的是Iterator接口中的hasNext这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class PropertyTokenizer implements Iterator&lt;PropertyTokenizer&gt; &#123;</span><br><span class="line">private String name;</span><br><span class="line">private String indexedName;</span><br><span class="line">private String index;</span><br><span class="line">private String children;</span><br><span class="line"></span><br><span class="line">public PropertyTokenizer(String fullname) &#123;</span><br><span class="line">int delim = fullname.indexOf(&apos;.&apos;);</span><br><span class="line">if (delim &gt; -1) &#123;</span><br><span class="line">name = fullname.substring(0, delim);</span><br><span class="line">children = fullname.substring(delim + 1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">name = fullname;</span><br><span class="line">children = null;</span><br><span class="line">&#125;</span><br><span class="line">indexedName = name;</span><br><span class="line">delim = name.indexOf(&apos;[&apos;);</span><br><span class="line">if (delim &gt; -1) &#123;</span><br><span class="line">index = name.substring(delim + 1, name.length() - 1);</span><br><span class="line">name = name.substring(0, delim);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getIndex() &#123;</span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getIndexedName() &#123;</span><br><span class="line">return indexedName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getChildren() &#123;</span><br><span class="line">return children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">return children != null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PropertyTokenizer next() &#123;</span><br><span class="line">return new PropertyTokenizer(children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void remove() &#123;</span><br><span class="line">throw new UnsupportedOperationException(</span><br><span class="line">&quot;Remove is not supported, as it has no meaning in the context of properties.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这个类传入一个字符串到构造函数，然后提供了iterator方法对解析后的子串进行遍历，是一个很常用的方法类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。&quot;&gt;&lt;a href=&quot;#有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。&quot; class=&quot;headerlink&quot; title=&quot;有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。&quot;&gt;&lt;/a&gt;有个笑话说：别管什么算法设计模式，老夫写代码就是一把梭。诚然，业务模型简单的时候，也许if-else或者switch语句要胜于复杂的设计模式应用。随着业务发展，业务模型大量耦合层级更复杂的时候，面对屎山一样的代码，看不下去了，要refactor，那么设计模式相关知识就很重要。这里记一篇通过Mybatis源码中总结到的设计模式。&lt;/h5&gt;
    
    </summary>
    
    
      <category term="back-end" scheme="https://github.com/DJoeyZhang/tags/back-end/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的一些配置优化</title>
    <link href="https://github.com/DJoeyZhang/archives/51e3ccae.html"/>
    <id>https://github.com/DJoeyZhang/archives/51e3ccae.html</id>
    <published>2020-01-13T09:53:00.000Z</published>
    <updated>2020-01-14T08:54:00.940Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～"><a href="#作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～" class="headerlink" title="作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～"></a>作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～</h4><a id="more"></a><h6 id="nginx-的2种安装方式："><a href="#nginx-的2种安装方式：" class="headerlink" title="nginx 的2种安装方式："></a>nginx 的2种安装方式：<br></h6><p>1、源码包安装<br>2、yum（apt-get）安装区别为如果用yum安装的话，很方便，并且基本不报错。如果对性能要求不是很高的话，可以采用这种安装方式（比如测试环境）<br><br>如果是源码包安装的话，因为在服务器上编译的软件，会让nginx的性能相对更高一些，建议生产环境使用源码包安装</p><h6 id="一、基本配置优化（优化后配置样例，可以改后直接上生产）"><a href="#一、基本配置优化（优化后配置样例，可以改后直接上生产）" class="headerlink" title="一、基本配置优化（优化后配置样例，可以改后直接上生产）"></a>一、基本配置优化（优化后配置样例，可以改后直接上生产）<br></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#头部配置</span><br><span class="line">user  nginx nginx;    #定义nginx的启动用户，不建议使用root</span><br><span class="line">worker_processes  4;　　#定位为cpu的内核数量，因为我的环境配置是4核，所以就写4。不过这值最多也就是8，8个以上也就没什么意义了，想继续提升性能只能参考下面一项配置</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000;　　#此项配置为开启多核CPU，对你先弄提升性能有很大帮助nginx默认是不开启的,1为开启，0为关闭，因此先开启第一个倒过来写，</span><br><span class="line">第一位0001（关闭第四个、关闭第三个、关闭第二个、开启第一个）</span><br><span class="line">第二位0010（关闭第四个、关闭第三个、开启第二个、关闭第一个）</span><br><span class="line">第三位0100（关闭第四个、开启第三个、关闭第二个、关闭第一个）</span><br><span class="line">后面的依次类推，有智商的应该都可以看懂了吧？  那么如果是16核或者8核cpu，就注意为00000001、00000010、00000100，总位数与cpu核数一样。</span><br><span class="line"> </span><br><span class="line">error_log  /data/logs/nginx/error.log crit;　　　　　　#这两项基本不用我说</span><br><span class="line">pid        /usr/local/nginx/nginx.pid;</span><br><span class="line"> </span><br><span class="line">#Specifies the value for maximum file descriptors that can be opened by this process.</span><br><span class="line">worker_rlimit_nofile 65535;　　　　#这个值为nginx的worker进程打开的最大文件数，如果不配置，会读取服务器内核参数（通过ulimit -a查看），如果内核的值设置太低会让nginx报错（too many open</span><br><span class="line">file），但是在此设置后，就会读取自己配置的参数不去读取内核参数</span><br><span class="line"> </span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">  use epoll;　　　　#客户端线程轮询方法、内核2.6版本以上的建议使用epoll</span><br><span class="line">  worker_connections 65535;　　#设置一个worker可以打开的最大连接数</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">        include       mime.types;</span><br><span class="line">        default_type  application/octet-stream;</span><br><span class="line"> </span><br><span class="line">        #charset  gb2312;</span><br><span class="line">        server_tokens  off;　　　　#为错误页面上的nginx版本信息，建议关闭，提升安全性</span><br><span class="line"> </span><br><span class="line">        server_names_hash_bucket_size 128;</span><br><span class="line">        client_header_buffer_size 32k;</span><br><span class="line">        large_client_header_buffers 4 32k;</span><br><span class="line">        client_max_body_size 8m;</span><br><span class="line"> </span><br><span class="line">        sendfile on;　　　　　　#开启sendfile（）函数，sendfile可以再磁盘和tcp socket之间互相copy数据。</span><br><span class="line">        tcp_nopush     on;　　#告诉nginx在数据包中发送所有头文件，而不是一个一个的发</span><br><span class="line"> </span><br><span class="line">        #keepalive_timeout 15;</span><br><span class="line">        keepalive_timeout 120;</span><br><span class="line"> </span><br><span class="line">        tcp_nodelay on;</span><br><span class="line"> </span><br><span class="line">        proxy_intercept_errors on;</span><br><span class="line">        fastcgi_intercept_errors on;</span><br><span class="line">        fastcgi_connect_timeout 1300;</span><br><span class="line">        fastcgi_send_timeout 1300;</span><br><span class="line">        fastcgi_read_timeout 1300;</span><br><span class="line">        fastcgi_buffer_size 512k;</span><br><span class="line">        fastcgi_buffers 4 512k;</span><br><span class="line">        fastcgi_busy_buffers_size 512k;</span><br><span class="line">        fastcgi_temp_file_write_size 512k;</span><br><span class="line"> </span><br><span class="line">        proxy_connect_timeout      20s;</span><br><span class="line">        proxy_send_timeout         30s;</span><br><span class="line">        proxy_read_timeout         30s;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        gzip on;　　　　　　　　　　　　#gzip是告诉nginx采用gzip后的数据来传输文件，会大量减少我们的发数据的量</span><br><span class="line">        gzip_min_length  1k;</span><br><span class="line">        gzip_buffers     4 16k;</span><br><span class="line">        gzip_http_version 1.0;</span><br><span class="line">        gzip_comp_level 2;</span><br><span class="line">        gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">        gzip_vary on;</span><br><span class="line">        gzip_disable msie6;</span><br><span class="line">        #limit_zone  crawler  $binary_remote_addr  10m;</span><br><span class="line"> </span><br><span class="line">log_format  main  &apos;$http_host $remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &apos;</span><br><span class="line">                  &apos;$request_time $upstream_response_time&apos;;</span><br><span class="line"> </span><br><span class="line"> #proxy_temp_path和proxy_cache_path指定的路径必须在同一分区,因为它们之间是硬链接的关系</span><br><span class="line"> #proxy_temp_path /var/cache/nginx/proxy_temp_dir;</span><br><span class="line"> #设置Web缓存区名称为cache_one，内存缓存空间大小为200MB，1天没有被访问的内容自动清除，硬盘缓存空间大小为30GB。</span><br><span class="line"> #proxy_cache_path /var/cache/nginx/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g;</span><br><span class="line"> </span><br><span class="line">        include /usr/local/nginx/conf/vhosts/*.conf;</span><br><span class="line"> </span><br><span class="line">        error_page  404   = https://www.niu.com/404/;</span><br><span class="line">        #error_page   500 502 503 504 = http://service.niu.com/alien/;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 如果是高并发架构，需要在nginx的服务器上添加如下的内核参数<br>这些参数追加到/etc/sysctl.conf,然后执行sysctl -p 生效。<br></p><p> #每个网络接口接收数据包速度比内核处理速度快的时候，允许发送队列数目数据包的最大数net.core.netdev_max_backlog = 262144<br></p><p> #调节系统同时发起的tcp连接数net.core.somaxconn = 262144<br></p><p> #该参数用于设定系统中最多允许存在多少TCP套接字不被关联到任何一个用户文件句柄上，主要目的为防止Ddos攻击net.ipv4.tcp_max_orphans = 262144<br></p><p> #该参数用于记录尚未收到客户端确认信息的连接请求的最大值net.ipv4.tcp_max_syn_backlog = 262144<br></p><p> #nginx服务上建议关闭（既为0）net.ipv4.tcp_timestamps = 0<br></p><p> #该参数用于设置内核放弃TCP连接之前向客户端发送SYN+ACK包的数量，为了建立对端的连接服务，服务器和客户端需要进行三次握手，第二次握手期间，内核需要发送SYN并附带一个回应前一个SYN的ACK，这个参数主要影响这个过程，一般赋予值为1，即内核放弃连接之前发送一次SYN＋ACK包。net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syn_retries = 1<br></p><h6 id="二、nginx配置lua，添加接口返回值，方便开发debug，"><a href="#二、nginx配置lua，添加接口返回值，方便开发debug，" class="headerlink" title="二、nginx配置lua，添加接口返回值，方便开发debug，"></a>二、nginx配置lua，添加接口返回值，方便开发debug，<br></h6><h6 id="三、nginx配置https"><a href="#三、nginx配置https" class="headerlink" title="三、nginx配置https"></a>三、nginx配置https</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#server端基本配置&lt;br&gt;server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl spdy;</span><br><span class="line">    server_name io.123.com;</span><br><span class="line">    include      ssl/io.com;　　　　　　#注意看下一个文件</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://lb_io;</span><br><span class="line">        if ($scheme = http ) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;　　　　#此项配置为转换为https的基本配置</span><br><span class="line">        &#125;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line"> </span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    access_log /data/logs/nginx/access/niuaero.log main;</span><br><span class="line">&#125;</span><br><span class="line">　　</span><br><span class="line"></span><br><span class="line">ssl_certificate      ssl/ca/io.com.pem;　　　　#这个为购买的https证书，供应商会生成</span><br><span class="line">ssl_certificate_key  ssl/ca/io.com.key;</span><br><span class="line">ssl_session_timeout  5m;</span><br><span class="line">ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#启用TLS1.1、TLS1.2要求OpenSSL1.0.1及以上版本，若您的OpenSSL版本低于要求，请使用 ssl_protocols TLSv1;</span><br><span class="line">ssl_ciphers  HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM;</span><br><span class="line">ssl_prefer_server_ciphers   on;</span><br></pre></td></tr></table></figure><h6 id="四、nginx配置反爬虫"><a href="#四、nginx配置反爬虫" class="headerlink" title="四、nginx配置反爬虫"></a>四、nginx配置反爬虫<br></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#以下内容添加nginx虚拟主机配置里，proxypass之后&lt;br&gt;&lt;br&gt;if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123; </span><br><span class="line">     return 403; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">#禁止指定UA及UA为空的访问 </span><br><span class="line">if ($http_user_agent ~ &quot;WinHttp|WebZIP|FetchURL|node-superagent|java/|FeedDemon|Jullo|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|Java|Feedly|Apache-HttpAsyncClient|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|HttpClient|MJ12bot|heritrix|EasouSpider|Ezooms|BOT/0.1|YandexBot|FlightDeckReports|Linguee Bot|^$&quot; ) &#123; </span><br><span class="line">     return 403;              </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">#禁止非GET|HEAD|POST方式的抓取 </span><br><span class="line">if ($request_method !~ ^(GET|HEAD|POST)$) &#123; </span><br><span class="line">    return 403; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～&quot;&gt;&lt;a href=&quot;#作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～&quot; class=&quot;headerlink&quot; title=&quot;作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～&quot;&gt;&lt;/a&gt;作为一个大前端开发，可能会在业务场景中遇到使用nodeJs做中间层的需求。OK，我们用node写了中间层，去调用一些基础服务或者CURD操作，这时候问题来了，你发现请求响应缓慢，于是你查看了公司服务器的负载情况，发现多台性能不同的服务器负载均衡配置不合理。于是你打开了nginx手册，试图进行一些优化～&lt;/h4&gt;
    
    </summary>
    
    
      <category term="back-end" scheme="https://github.com/DJoeyZhang/tags/back-end/"/>
    
  </entry>
  
  <entry>
    <title>React-Native开发之VSCode配置规范</title>
    <link href="https://github.com/DJoeyZhang/archives/d0170db3.html"/>
    <id>https://github.com/DJoeyZhang/archives/d0170db3.html</id>
    <published>2019-11-04T02:39:00.000Z</published>
    <updated>2020-01-14T08:56:01.016Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码风格及检查"><a href="#代码风格及检查" class="headerlink" title="代码风格及检查"></a>代码风格及检查</h4><p>代码风格检查目前一致认为用eslint比较好，并且目前ReactNative项目的开发基本都使用VSCode，因此进行代码规则检查使用VSCode的eslint插件。<br><a id="more"></a></p><h5 id="关于插件的安装及配置文件的生成（以下基于VSCode）"><a href="#关于插件的安装及配置文件的生成（以下基于VSCode）" class="headerlink" title="关于插件的安装及配置文件的生成（以下基于VSCode）"></a>关于插件的安装及配置文件的生成（以下基于VSCode）</h5><pre><code>1、首先是插件的安装，打开VSCode的扩展商店搜索eslint，找到以后下载并安装，重启VSCode。2、生成配置文件，使用终端执行npm install eslint (如果是全局安装加参数-g，如果是本地在项目根目录执行命令)，安装成功后eslint --init初始化eslint配置文件3、基础规则库的安装，目前使用的基础规则是eslint推荐规则及react推荐规则，因此需要npm install eslint-plugin-react4、除此之外还需要npm install babel-eslint</code></pre><p>最后，使用统一的配置文件内容覆盖自己项目中的（文件名：.eslintrc.js），目前规则还不算完整需要大家来填充修改</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>eslintrc.js</p><h5 id="代码格式化篇"><a href="#代码格式化篇" class="headerlink" title="代码格式化篇"></a>代码格式化篇</h5><p>prettier目前是功能比较强的代码格式化工具，可以根据eslint规则格式化代码（有一些规则可能不生效，需要单独补充）</p><p>关于插件的安装及规则设置</p><pre><code>1、首先是插件的安装，打开VSCode的扩展商店搜索prettier，找到以后下载并安装，重启VSCode。2、在usersetting 里面增加设置</code></pre><p>“prettier.eslintIntegration”: true, //让prettier使用eslint的代码格式进行校验<br>“editor.formatOnSave”: true,<br>“javascript.format.enable”: false<br>“editor.tabSize”: 4,<br>“editor.detectIndentation”: false,</p><p>注意事项：<br>公共文件，最好不要做代码格式化，容易在代码merge时引起许多冲突</p><p>如果需求格式化，约定在项目提测前，某个人格式化，然后其他人及时同步一下</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;代码风格及检查&quot;&gt;&lt;a href=&quot;#代码风格及检查&quot; class=&quot;headerlink&quot; title=&quot;代码风格及检查&quot;&gt;&lt;/a&gt;代码风格及检查&lt;/h4&gt;&lt;p&gt;代码风格检查目前一致认为用eslint比较好，并且目前ReactNative项目的开发基本都使用VSCode，因此进行代码规则检查使用VSCode的eslint插件。&lt;br&gt;
    
    </summary>
    
    
      <category term="React-native" scheme="https://github.com/DJoeyZhang/tags/React-native/"/>
    
  </entry>
  
  <entry>
    <title>Debounce函数及lodash库的一些思考</title>
    <link href="https://github.com/DJoeyZhang/archives/20cd7dd6.html"/>
    <id>https://github.com/DJoeyZhang/archives/20cd7dd6.html</id>
    <published>2019-01-21T06:05:00.000Z</published>
    <updated>2020-01-14T08:56:16.911Z</updated>
    
    <content type="html"><![CDATA[<p>hybrid-native开发或者reat-native开发时，不可避免涉及到js脚本编写。对于大前端来说，对于es6/es7的语法熟悉是必备素质。这里介绍一个前端常用的工具库lodash。<br><a id="more"></a></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>今天在优化大搜索页面时碰到一个问题，feedback返回用户反馈搜索页面卡顿。先定位到原先的代码：是在 &lt; TextInput &gt; 的onchange回调中，请求suggest接口返回模糊搜索结果。但是在IOS设备上会有一个问题：键盘输入拼音时系统会把未输入完的结果录到input组建中，导致onchange回调多次调用，suggest接口频繁请求，hint内容不断刷新，造成页面卡顿的同时，也增加了接口的负担。</p><h4 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h4><p>经过分析，我认为用户使用模糊搜索具备 <a href="http://f.dataguru.cn/spark-888363-1-1.html" target="_blank" rel="noopener">幂等性</a> .即在一段时间内用户输入的key word应返回相同的suggest。不应频繁调用接口。<br>基于以上思想，很自然想到setTimeout()函数，用户输入停止后设置一个延时再请求网络,但是直接在回调里setTimeout这个做法十分hardcode。于是逛了一下万能的gayHub,发现了一个不错的解决方案:使用debounce函数去除抖动。</p><h4 id="lodash介入"><a href="#lodash介入" class="headerlink" title="lodash介入"></a>lodash介入</h4><p>这里的debounce函数属于鼎鼎大名的lodash库(<a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a>)<br><a href="https://www.lodashjs.com/docs/4.17.5.html#debounce" target="_blank" rel="noopener">debounce函数的官方文档</a></p><p><a href="https://lodash.com/docs/4.17.5" target="_blank" rel="noopener">lodash官方文档</a><br><a href="http://lodash.think2011.net/keys" target="_blank" rel="noopener">lodash中文文档</a></p><h4 id="debounce-与-throttle"><a href="#debounce-与-throttle" class="headerlink" title="debounce 与 throttle"></a>debounce 与 throttle</h4><p>debounce(防抖)：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间，举个简单的例子，我们要根据用户输入做suggest，每当用户按下键盘的时候都可以取消前一次，并且只关心最后一次输入的时间就行了。</p><p>throttle(节流)：将一个函数的调用频率限制在一定阈值内，例如 1s 内一个函数不能被调用两次。<br>这里拿出debounce的源码解析一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, options) &#123;</span><br><span class="line">    let lastArgs,</span><br><span class="line">        lastThis,</span><br><span class="line">        maxWait,</span><br><span class="line">        result,</span><br><span class="line">        timerId,</span><br><span class="line">        lastCallTime</span><br><span class="line"></span><br><span class="line">    // 参数初始化</span><br><span class="line">    let lastInvokeTime = 0 // func 上一次执行的时间</span><br><span class="line">    let leading = false</span><br><span class="line">    let maxing = false</span><br><span class="line">    let trailing = true</span><br><span class="line"></span><br><span class="line">    // 基本的类型判断和处理</span><br><span class="line">    if (typeof func != &apos;function&apos;) &#123;</span><br><span class="line">        throw new TypeError(&apos;Expected a function&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    wait = +wait || 0</span><br><span class="line">    if (isObject(options)) &#123;</span><br><span class="line">        // 对配置的一些初始化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function invokeFunc(time) &#123;</span><br><span class="line">        const args = lastArgs</span><br><span class="line">        const thisArg = lastThis</span><br><span class="line"></span><br><span class="line">        lastArgs = lastThis = undefined</span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        result = func.apply(thisArg, args)</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function leadingEdge(time) &#123;</span><br><span class="line">        // Reset any `maxWait` timer.</span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        // 为 trailing edge 触发函数调用设定定时器</span><br><span class="line">        timerId = setTimeout(timerExpired, wait)</span><br><span class="line">        // leading = true 执行函数</span><br><span class="line">        return leading ? invokeFunc(time) : result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   function remainingWait(time) &#123;</span><br><span class="line">        const timeSinceLastCall = time - lastCallTime // 距离上次debounced函数被调用的时间</span><br><span class="line">        const timeSinceLastInvoke = time - lastInvokeTime // 距离上次函数被执行的时间</span><br><span class="line">        const timeWaiting = wait - timeSinceLastCall // 用 wait 减去 timeSinceLastCall 计算出下一次trailing的位置</span><br><span class="line"></span><br><span class="line">        // 两种情况</span><br><span class="line">        // 有maxing:比较出下一次maxing和下一次trailing的最小值，作为下一次函数要执行的时间</span><br><span class="line">        // 无maxing：在下一次trailing时执行 timerExpired</span><br><span class="line">        return maxing</span><br><span class="line">            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class="line">            : timeWaiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据时间判断 func 能否被执行</span><br><span class="line">    function shouldInvoke(time) &#123;</span><br><span class="line">        const timeSinceLastCall = time - lastCallTime</span><br><span class="line">        const timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">        // 几种满足条件的情况</span><br><span class="line">        return (lastCallTime === undefined //首次</span><br><span class="line">            || (timeSinceLastCall &gt;= wait) // 距离上次被调用已经超过 wait</span><br><span class="line">            || (timeSinceLastCall &lt; 0) //系统时间倒退</span><br><span class="line">            || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)) //超过最大等待时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function timerExpired() &#123;</span><br><span class="line">        const time = Date.now()</span><br><span class="line">        // 在 trailing edge 且时间符合条件时，调用 trailingEdge函数，否则重启定时器</span><br><span class="line">        if (shouldInvoke(time)) &#123;</span><br><span class="line">            return trailingEdge(time)</span><br><span class="line">        &#125;</span><br><span class="line">        // 重启定时器，保证下一次时延的末尾触发</span><br><span class="line">        timerId = setTimeout(timerExpired, remainingWait(time))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function trailingEdge(time) &#123;</span><br><span class="line">        timerId = undefined</span><br><span class="line"></span><br><span class="line">        // 有lastArgs才执行，意味着只有 func 已经被 debounced 过一次以后才会在 trailing edge 执行</span><br><span class="line">        if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">            return invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">        // 每次 trailingEdge 都会清除 lastArgs 和 lastThis，目的是避免最后一次函数被执行了两次</span><br><span class="line">        // 举个例子：最后一次函数执行的时候，可能恰巧是前一次的 trailing edge，函数被调用，而这个函数又需要在自己时延的 trailing edge 触发，导致触发多次</span><br><span class="line">        lastArgs = lastThis = undefined</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function cancel() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function flush() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function pending() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function debounced(...args) &#123;</span><br><span class="line">        const time = Date.now()</span><br><span class="line">        const isInvoking = shouldInvoke(time) //是否满足时间条件</span><br><span class="line"></span><br><span class="line">        lastArgs = args</span><br><span class="line">        lastThis = this</span><br><span class="line">        lastCallTime = time  //函数被调用的时间</span><br><span class="line"></span><br><span class="line">        if (isInvoking) &#123;</span><br><span class="line">            if (timerId === undefined) &#123; // 无timerId的情况有两种：1.首次调用 2.trailingEdge执行过函数</span><br><span class="line">                return leadingEdge(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">            if (maxing) &#123;</span><br><span class="line">                // Handle invocations in a tight loop.</span><br><span class="line">                timerId = setTimeout(timerExpired, wait)</span><br><span class="line">                return invokeFunc(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 负责一种case：trailing 为 true 的情况下，在前一个 wait 的 trailingEdge 已经执行了函数；</span><br><span class="line">        // 而这次函数被调用时 shouldInvoke 不满足条件，因此要设置定时器，在本次的 trailingEdge 保证函数被执行</span><br><span class="line">        if (timerId === undefined) &#123;</span><br><span class="line">            timerId = setTimeout(timerExpired, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel</span><br><span class="line">    debounced.flush = flush</span><br><span class="line">    debounced.pending = pending</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首次进入函数时因为 lastCallTime === undefined 并且 timerId === undefined，所以会执行 leadingEdge，如果此时 leading 为 true 的话，就会执行 func。同时，这里会设置一个定时器，在等待 wait(s) 后会执行 timerExpired，timerExpired 的主要作用就是触发 trailing。</p><p>如果在还未到 wait 的时候就再次调用了函数的话,会更新 lastCallTime，并且因为此时 isInvoking 不满足条件，所以这次什么也不会执行。</p><p>时间到达 wait 时，就会执行我们一开始设定的定时器timerExpired，此时因为time-lastCallTime &lt; wait，所以不会执行 trailingEdge。</p><p>这时又会新增一个定时器，下一次执行的时间是 remainingWait，这里会根据是否有 maxwait 来作区分：</p><p>如果没有 maxwait，定时器的时间是 wait - timeSinceLastCall，保证下一次 trailing 的执行。</p><p>如果有 maxing，会比较出下一次 maxing 和下一次 trailing 的最小值，作为下一次函数要执行的时间。</p><p>最后，如果不再有函数调用，就会在定时器结束时执行 trailingEdge。</p><h4 id="lodash其他常用函数："><a href="#lodash其他常用函数：" class="headerlink" title="lodash其他常用函数："></a>lodash其他常用函数：</h4><p><strong>遍历对象类型：</strong><br>_.forEach(obj, (value, key) =&gt; { console.log(value) })</p><p><strong>遍历和过滤的快捷方式：</strong><br>从一组对象中摘取出某个属性的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#123; n: 1 &#125;, &#123; n: 2 &#125;]</span><br><span class="line">// ES6</span><br><span class="line">arr.map((obj) =&gt; obj.n)</span><br><span class="line">// Lodash</span><br><span class="line">_.map(arr, &apos;n&apos;)</span><br></pre></td></tr></table></figure></p><p>当对象类型的嵌套层级很多时，Lodash 的快捷方式就更实用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [</span><br><span class="line">  &#123; a: [ &#123; n: 1 &#125; ]&#125;,</span><br><span class="line">  &#123; b: [ &#123; n: 1 &#125; ]&#125;</span><br><span class="line">]</span><br><span class="line">// ES6</span><br><span class="line">arr.map((obj) =&gt; obj.a[0].n) // TypeError: 属性 &apos;a&apos; 在 arr[1] 中未定义</span><br><span class="line">// Lodash</span><br><span class="line">_.map(arr, &apos;a[0].n&apos;) // =&gt; [1, undefined]</span><br></pre></td></tr></table></figure></p><p>可以看到，Lodash 的快捷方式还对 null 值做了容错处理。此外还有过滤快捷方式，以下是从 Lodash 官方文档中摘取的示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let users = [</span><br><span class="line">  &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36, &apos;active&apos;: true &#125;,</span><br><span class="line">  &#123; &apos;user&apos;: &apos;fred&apos;,   &apos;age&apos;: 40, &apos;active&apos;: false &#125;</span><br><span class="line">];</span><br><span class="line">// ES6</span><br><span class="line">users.filter((o) =&gt; o.active)</span><br><span class="line">// Lodash</span><br><span class="line">_.filter(users, &apos;active&apos;)</span><br><span class="line">_.filter(users, [&apos;active&apos;, true])</span><br><span class="line">_.filter(users, &#123;&apos;active&apos;: true, &apos;age&apos;: 36&#125;)</span><br></pre></td></tr></table></figure></p><p><strong> 链式调用和惰性求值:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">et lines = `</span><br><span class="line">an apple orange the grape</span><br><span class="line">banana an apple melon</span><br><span class="line">an orange banana apple</span><br><span class="line">`.split(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">_.chain(lines)</span><br><span class="line">  .flatMap(line =&gt; line.split(/\s+/))</span><br><span class="line">  .filter(word =&gt; word.length &gt; 3)</span><br><span class="line">  .groupBy(_.identity)</span><br><span class="line">  .mapValues(_.size)</span><br><span class="line">  .forEach((count, word) =&gt; &#123; console.log(word, count) &#125;)</span><br><span class="line"></span><br><span class="line">// apple 3</span><br><span class="line">// orange 2</span><br><span class="line">// grape 1</span><br><span class="line">// banana 2</span><br><span class="line">// melon 1</span><br></pre></td></tr></table></figure></p><p><strong>解构赋值和箭头函数:</strong><br>ES6 引入了解构赋值、箭头函数等新的语言特性，可以用来替换 Lodash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Lodash</span><br><span class="line">_.head([1, 2, 3]) // =&gt; 1</span><br><span class="line">_.tail([1, 2, 3]) // =&gt; [2, 3]</span><br><span class="line">// ES6 解构赋值（destructuring syntax）</span><br><span class="line">const [head, ...tail] = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// Lodash</span><br><span class="line">let say = _.rest((who, fruits) =&gt; who + &apos; likes &apos; + fruits.join(&apos;,&apos;))</span><br><span class="line">say(&apos;Jerry&apos;, &apos;apple&apos;, &apos;grape&apos;)</span><br><span class="line">// ES6 spread syntax</span><br><span class="line">say = (who, ...fruits) =&gt; who + &apos; likes &apos; + fruits.join(&apos;,&apos;)</span><br><span class="line">say(&apos;Mary&apos;, &apos;banana&apos;, &apos;orange&apos;)</span><br><span class="line"></span><br><span class="line">// Lodash</span><br><span class="line">_.constant(1)() // =&gt; 1</span><br><span class="line">_.identity(2) // =&gt; 2</span><br><span class="line">// ES6</span><br><span class="line">(x =&gt; (() =&gt; x))(1)() // =&gt; 1</span><br><span class="line">(x =&gt; x)(2) // =&gt; 2</span><br><span class="line"></span><br><span class="line">// 偏应用（Partial application）</span><br><span class="line">let add = (a, b) =&gt; a + b</span><br><span class="line">// Lodash</span><br><span class="line">let add1 = _.partial(add, 1)</span><br><span class="line">// ES6</span><br><span class="line">add1 = b =&gt; add(1, b)</span><br><span class="line"></span><br><span class="line">// 柯里化（Curry）</span><br><span class="line">// Lodash</span><br><span class="line">let curriedAdd = _.curry(add)</span><br><span class="line">let add1 = curriedAdd(1)</span><br><span class="line">// ES6</span><br><span class="line">curriedAdd = a =&gt; b =&gt; a + b</span><br><span class="line">add1 = curriedAdd(1)</span><br></pre></td></tr></table></figure></p><h4 id="一些参考信息："><a href="#一些参考信息：" class="headerlink" title="一些参考信息："></a>一些参考信息：</h4><p><a href="https://www.sitepoint.com/lodash-features-replace-es6/" target="_blank" rel="noopener">10 Lodash Features You Can Replace with ES6</a><br><a href="https://derickbailey.com/2016/09/12/does-es6-mean-the-end-of-underscore-lodash/" target="_blank" rel="noopener">Does ES6 Mean The End Of Underscore / Lodash?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hybrid-native开发或者reat-native开发时，不可避免涉及到js脚本编写。对于大前端来说，对于es6/es7的语法熟悉是必备素质。这里介绍一个前端常用的工具库lodash。&lt;br&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="https://github.com/DJoeyZhang/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题及一些思考</title>
    <link href="https://github.com/DJoeyZhang/archives/f8185732.html"/>
    <id>https://github.com/DJoeyZhang/archives/f8185732.html</id>
    <published>2019-01-08T06:42:00.000Z</published>
    <updated>2020-01-14T08:56:40.503Z</updated>
    
    <content type="html"><![CDATA[<p>所谓,温故而知新，可以为师矣！这段时间到处面试，结合工作和网上一些文章，深感学有涯而知无涯~<br>在这里梳理一下，供学习思考。本篇主要是 native开发涉及到的Java知识点和Android方面知识。<br></p><hr><a id="more"></a><h3 id="JAVA基础-Android原生开发Java多线程问题必问"><a href="#JAVA基础-Android原生开发Java多线程问题必问" class="headerlink" title="JAVA基础(Android原生开发Java多线程问题必问):"></a>JAVA基础(Android原生开发Java多线程问题必问):</h3><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别?"></a>线程和进程的区别?</h4><p>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，<br>而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><h4 id="线程池的概念以及应用场景"><a href="#线程池的概念以及应用场景" class="headerlink" title="线程池的概念以及应用场景?"></a>线程池的概念以及应用场景?</h4><p>多线程编程下如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务,线程池技术的出现就很好的解决了上面问题,可以更好的提供性能,并有效控制系统中并发线程的数量(线程池的最大线程数参数可以控制系统中并发线程数不超过此数)。</p><p><a href="https://www.cnblogs.com/ruiati/p/6134131.html" target="_blank" rel="noopener">关于Java四种类型线程池详解</a></p><h4 id="volatitle与synchronize区别，锁的两种特性：可见性与互斥性"><a href="#volatitle与synchronize区别，锁的两种特性：可见性与互斥性" class="headerlink" title="volatitle与synchronize区别，锁的两种特性：可见性与互斥性? "></a><strong>volatitle与synchronize区别，锁的两种特性：可见性与互斥性? </strong></h4><p>首先，二者都是保证了在竞态条件下，数据的一致性。<br>使用上：volatile只用来声明变量；synchronize可以用来修饰方法体。</p><p>volatile，它能够使变量在值发生改变时尽快地让其他线程知道。<br>所谓可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。它在某些情况下比synchronized的开销更小，如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p><strong> Volatile使用场景：</strong><br>常见的就是单例模式中,对字段的声明,加上这个关键字。保证在不同线程中单例属性的有效性。</p><p><strong> Volatile原理:</strong><br>先将当前处理器缓存行的数据会写回到系统内存,这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。最后,当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。如此循环反复保证共享变量的值是一致的。</p><p><strong> synchronize的理解及原理：</strong><br>A: 每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：<br>    1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。<br>    2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.<br>    3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p><p>B:执行monitorexit的线程必须是objectref所对应的monitor的所有者。<br>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><p>volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取。synchronized则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞。</p><h4 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全?"></a>如何保证线程安全?</h4><p>简单来说，线程安全就是：在多线程环境中，能永远保证程序的正确性。因此,只有存在共享数据时才需要考虑线程安全问题。</p><p>解决方案1:Java多线程支持引入同步监视器来解决这个问题,使用同步监视器的通用方法就是同步代码块,使用synchronize(obj)代码块,(目的:任何时刻只能有一个线程可以获得对同步监视器的锁定,当同步代码块执行完成后,该线程会释放对该同步监视器的锁定) 推荐使用可能被并发访问的共享资源充当同步监视器,逻辑大概就是   加锁–&gt;修改–&gt;释放锁 </p><p>解决方案2:通过显示定义同步锁对象实现同步,在这种机制下,同步锁用Lock对象充当,Lock允许实现更灵活的结构,有差别很大的属性,使用Lock对象来进行同步,加锁和释放锁出现在不同的作用范围内,通常建议使用finally块来确保在必要时候释放锁。</p><h4 id="简述Java中为什么会出现死锁"><a href="#简述Java中为什么会出现死锁" class="headerlink" title="简述Java中为什么会出现死锁?"></a>简述Java中为什么会出现死锁?</h4><p>当两个线程相互等待对方释放同步监视器时就会发生死锁,Java虚拟机没有监测也没有采取措施来处理死锁情况,所以多线程编程时应该采取措施避免死锁出现.一旦出现死锁,整个程序既不会发生任何异常,也不会给出任何提示,只是所有线程处于阻塞状态,无法继续。</p><h4 id="简述多态"><a href="#简述多态" class="headerlink" title="简述多态?"></a>简述多态?</h4><p>一句话:父类引用指向子类对象。Father f = new Son();<br>概念：个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>由多态引申的概念:向上转型</p><p>它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</p><p><strong>Java实现多态有三个必要条件：继承、重写、向上转型。</strong></p><h4 id="对Java的理解"><a href="#对Java的理解" class="headerlink" title="对Java的理解?"></a>对Java的理解?</h4><p>可以从面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点谈。桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序,Android开发等等回答.</p><p><strong>抽象类与接口的联系与区别?</strong><br>相同点:<br>都不能直接实例化,接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化。</p><p>区别:<br>1、抽象类变量必须指向实现所有<strong>抽象方法</strong>的子类对象;接口变量必须指向实现所有<strong>接口</strong>方法的类对象。<br>2、抽象类要被子类继承(extends)，接口要被类实现(implement)。<br>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。<br>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个类实现接口的时候，如不能实现接口中全部方法，那么该类也只能为抽象类。<br>6、抽象方法只能声明，不能实现。abstract void abc();不能写成abstract void abc(){}。<br>7、抽象类里可以没有抽象方法。但一个类里有抽象方法，那么这个类只能是抽象类。<br>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。<br>10、接口可继承接口，并可多继承接口，但类只能单继承。</p><p>综述 : 特别是对于公用的实现代码，抽象类有它的优点。抽象类能够保证实现的层次关系，避免代码重复。然而，即使在使用抽象类的场合，也不要忽视通过接口定义行为模型的原则。从实践的角度来看，如果依赖于抽象类来定义行为，往往导致过于复杂的继承关系，而通过接口定义行为能够更有效地解耦，为代码的维护和修改带来方便。</p><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h4><p><strong> 值传递。</strong><br>Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p><h4 id="java数据类型（精度丢失，强制转型）-数据结构"><a href="#java数据类型（精度丢失，强制转型）-数据结构" class="headerlink" title="java数据类型（精度丢失，强制转型）/ 数据结构"></a>java数据类型（精度丢失，强制转型）/ 数据结构</h4><p><strong> float f=2.3;是否正确?</strong><br>不正确。<br>2.3是双精度数，将双精度型(double)赋值给浮点型(float)属于下转型(down-casting，也称为窄化)会造成精度损失，因此需要强制类型转换float f =(float)2.3; 或者写成float f =2.3F;。</p><p><strong> short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?</strong><br>对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。<br>而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p><p><strong> StringBuffer和StringBuilder的区别?</strong><br>StringBuilder：线程非安全的,但是效率高<br>StringBuffer：线程安全的,效率相对较低<br>单线程操作字符串缓冲区下操作大量数据推荐使用:StringBuilder<br>多线程操作字符串缓冲区下操作大量数据推荐使用:StringBuffer</p><p><strong> 数组和链表的区别？</strong><br>二者都属于一种数据结构。</p><p>从逻辑结构来看：<br>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标直接存取。</p><p>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项，非常繁琐）链表必须根据next指针找到下一个元素。</p><p>从内存存储来看：<br>(静态)数组从栈中分配空间, 对于程序员方便快速,但是自由度小。</p><p>链表从堆中分配空间, 自由度大但是申请管理比较麻烦。</p><p><strong> 从上面的比较可以看出，如果需要快速访问数据，很少或不插入和删除元素，就应该用数组；相反， 如果需要经常插入和删除元素就需要用链表数据结构了。</strong></p><h4 id="简述Java中的四种引用"><a href="#简述Java中的四种引用" class="headerlink" title="简述Java中的四种引用?"></a>简述Java中的四种引用?</h4><ul><li><strong>强引用（StrongReference）</strong><br>强引用是使用最普遍的引用。比如new 对象等等,如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</li><li><strong>软引用（SoftReference）</strong><br>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。软引用可用来实现内存敏感的高速缓存。</li><li><strong>弱引用（WeakReference）</strong><br>在java中，用java.lang.ref.WeakReference类来表示弱引用.  与软引用的区别在于：弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</li><li><strong>虚引用（PhantomReference）</strong><br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。</li></ul><p><strong> 强引用置为null,会不会被回收? </strong><br>只要是强引用就证明这个内存是在的，但是置为null,因此回收器在适当的时候回收,什么是适当时候，大体是使用内存占申请内存75%的时候，就启动回收线程。</p><p><strong> 如何保证多线程读写文件的安全? </strong><br>加锁,可以参考上面的线程安全</p><h4 id="单例模式的常见写法和优缺点分析"><a href="#单例模式的常见写法和优缺点分析" class="headerlink" title="单例模式的常见写法和优缺点分析?"></a>单例模式的常见写法和优缺点分析?</h4><p><strong> 懒汉式：</strong><br>第一次获取单例类的实例时创建。(优点:写法简单，且不存在多线程同步问题，避免了synchronized所造成的性能问题；缺点是：初始化类的时候就需要构造实例，（即便你还没有用到这个实例），因此在某些特定条件下会耗费内存。)<br><strong> 饿汉式：</strong><br>在类被加载的时候创建单例类的对象，类加载器负责加载类，并会保证只有一个线程在实例化单例类， (优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。缺点：在类装载的时候就完成实例化，没有达到Lazy Load的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。)</p><p>单例模式个人觉得最经典在项目里经常使用的写法（也称<strong>双重锁机制</strong>）：<br><a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">更多细节可以参考单例模式的8种写法</a></p><h4 id="单例模式的拓展？"><a href="#单例模式的拓展？" class="headerlink" title="单例模式的拓展？"></a>单例模式的拓展？</h4><p><strong> 使用静态内部类 实现单例模式 </strong></p><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，在《java并发编程实践》一书中推荐使用静态内部类单例模式。当然，可以根据个人偏好去使用。</p><p><strong> 实现管理者模式 </strong></p><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象，代码可读性强。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p><h4 id="网络请求-加密-持久化"><a href="#网络请求-加密-持久化" class="headerlink" title="网络请求 / 加密 / 持久化?"></a>网络请求 / 加密 / 持久化?</h4><p><strong> Http,Https相关? </strong></p><p>Http: (HTTP-Hypertext transfer protocol)又称:超文本传输协议 , 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p><p>Https:（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。Https情况下,电脑与服务器之间收发的信息传输将更加安全。</p><p><strong> HTTP协议的主要特点可概括如下：</strong></p><p>1.支持客户/服务器模式。</p><p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p><strong>Cookie 、Session  、 Token相关?</strong></p><p>Cookie:  它是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以key - Value 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的.(Cookie的作用是为了解决HTTP协议无状态的缺陷所作的努力)</p><p>cookie的内容主要包括：名字、值、过期时间、路径和域。<br>路径与域一起构成cookie的作用范围。<br>若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie.会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为 并不是规范规定的。<br>若设置了过期时间，浏览器就会把cookie保存在硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里cookie，不同的浏览器有不同的处理方式。</p><p>Session : 当用户打开某个web应用时，便与web服务器产生一次session。</p><p>简单的理解就是 : 服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。</p><p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对Cookie来说更安全 . 但是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p><p>Token: (英译汉 : 象征; 记号; 代币;)<br>token是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。</p><p><strong>Cookie和Session的区别:</strong></p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><ul><li>将登陆信息等重要信息存放为session</li><li>其他信息如果需要保留，可以放在cookie中</li></ul><p><strong>Token 和 Session 的区别: </strong></p><p>session和 token并不矛盾，作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。</p><p>如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态<br>App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。如果你的后端不是stateless的rest api,那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session.</p><p>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session认证只是简单的把User信息存储到Session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而Token，如果指的是OAuth Token或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App。其目的是让 某App有权利访问 某用户 的信息。</p><p>这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它 用户 上。转过来说Session。Session只提供一种简单的认证，即有此SID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么就无所谓了。</p><p>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；</p><p>cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；</p><p>session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p><h4 id="加密相关"><a href="#加密相关" class="headerlink" title="加密相关"></a>加密相关</h4><p><strong>对称加密: </strong></p><p>同一个密钥可以同时用作信息的加密和解密(注意:是同一个密钥)，这种加密方法称为对称加密，也称为单密钥加密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。因此,(“ target=”_blank”&gt;加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。在对称加密中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。接收方收到密文后，若想解读原文，则需要使用加密密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密。</p><p>对称加密算法的优点:算法公开、计算量小、加密速度快、加密效率高。</p><p>对称加密算法的缺点:在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p><p>对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。</p><p><strong>非对称加密:</strong></p><p>非对称加密算法需要两个密钥来进行加密和解密。<br>这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p><p>非对称加密与对称加密相比，其安全性更好：对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p><p>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><p><strong>MD5:</strong><br>MD5是一种信息摘要算法, 消息摘要是一种与消息认证码结合使用以确保消息完整性的技术。主要使用单向散列函数算法，可用于检验消息的完整性，和通过散列密码直接以文本形式保存等，目前广泛使用的算法有MD4、MD5、SHA-1。</p><h3 id="Android-UI-NetWork-handler"><a href="#Android-UI-NetWork-handler" class="headerlink" title="Android(UI / NetWork / handler):"></a>Android(UI / NetWork / handler):</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏:"></a>内存泄漏:</h4><p>当应用内部不再需要某个实例后，但是这个对象却仍然被引用，这个情况就叫做内存泄露(Memory Leak)。安卓虚拟机为每一个应用分配一定的内存空间，当内存泄露到达一定的程度就会造成内存溢出。</p><p><strong>导致内存泄露常见原因:</strong></p><ul><li>静态变量直接或者间接地引用了Activity对象就会造成内存泄露</li><li>Activity使用了静态的View(View会持有Activity的对象的引用)</li><li>ImageSpan引用了Activity Context</li><li>单例中引用了Activity的Context(需要使用Application的Context)</li><li>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏。</li><li>静态集合保存的对象没有及时消除(不使用的时候置为null)</li><li>在Java中,非静态(匿名)内部类会引用外部类对象,而静态内部类不会引用外部类对象</li><li>在Activity中,创建了非静态内部类(内部类直接或者间接引用了Activity)的静态成员变量</li><li>线程包括AsyncTask的使用,Activity退出后线程还在运行(线程在死循环),并且在线程中使用了Activity或view对象(解决方法:不要直接写死循环,可以设置一个布尔类型的TAG,当activity推出的时候,设置TAG为False)</li><li>Handler对象的使用,Activity退出后Handler还是有消息需要处理(解决方法:在退出activity之后,移除消息)</li><li>WebView造成的内存泄漏(在onDestory中销毁)</li></ul><p><strong>如何进行内存泄露分析?</strong></p><p>A: 通过Android Studio 窗口进行分析,查看内存分配情况,如果操作应用是内存一直往上涨说明存在内存泄露<br>B: 定位内存泄露分析的工具—MAT(Memory Analyzer tool)<br>C: 使用开源库LeakCanary快速定位内存泄露</p><h4 id="ANR相关"><a href="#ANR相关" class="headerlink" title="ANR相关"></a>ANR相关</h4><p>ANR全名Application Not Responding, 也就是”应用无响应”. 当操作在一段时间内系统无法处理时, 系统层面会弹出上图那样的ANR对话框.<br>在Android里, App的响应能力是由Activity Manager和Window Manager系统服务来监控的. 通常在如下两种情况下会弹出ANR对话框:</p><ul><li>5s内无法响应用户输入事件(例如键盘输入, 触摸屏幕等).</li><li>BroadcastReceiver在10s内无法结束.<br>造成以上两种情况的首要原因就是在主线程(UI线程)里面做了太多的阻塞耗时操作,例如文件读写, 数据库读写, 网络查询等等.</li></ul><h4 id="如何分析ANR"><a href="#如何分析ANR" class="headerlink" title="如何分析ANR?"></a>如何分析ANR?</h4><p>ANR产生时, 系统会生成一个traces.txt的文件放在/data/anr/下. 开发人员可通过adb命令将其导出到本地 (<strong>$ adb pull data/anr/traces.txt</strong>)通过分析,我们可以根据具体的日志查看Anr原因( 如: 普通阻塞,CPU满负荷,内存泄露 )</p><h4 id="Android开发下如何有效进行屏幕适配"><a href="#Android开发下如何有效进行屏幕适配" class="headerlink" title="Android开发下如何有效进行屏幕适配?"></a>Android开发下如何有效进行屏幕适配?</h4><ul><li>机型适配，去一些统计网站诸如友盟,现在叫友盟+去看一下市场上最流行的Android机型,有针对性的切图</li><li>屏幕适配，适配主流xhdpi屏幕尺寸，使用relativelayout，linerlayout等布局，多使用matchparent，wrapcontent，及配合weight,权重处理，</li><li>还有就是在代码中，设计到具体尺寸的要使用dp2px的转换，</li><li>图片使用可拉伸.9图片，imageview使用scaletype缩放；</li><li>使用权重,等比例,百分比布局等等.</li></ul><h4 id="今日头条屏幕适配的原理？"><a href="#今日头条屏幕适配的原理？" class="headerlink" title="今日头条屏幕适配的原理？"></a>今日头条屏幕适配的原理？</h4><p>首先计算出 density，计算公式：当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = densitydensity .<br>意思就是 1 dp 占当前设备多少像素计算density .<br>原因：在布局文件中填写的是什么单位，最后都会被转化为 px，系统就是通过上面的方法，将你在项目中任何地方填写的单位都转换为 px</p><p>但是，今日头条适配方案默认项目中只能以高或宽中的一个作为基准，来进行适配.</p><h4 id="Android下的数据存储方式有那些"><a href="#Android下的数据存储方式有那些" class="headerlink" title="Android下的数据存储方式有那些?"></a>Android下的数据存储方式有那些?</h4><ul><li>内部存储,直接存储在内部文件中</li><li>外部存储,首先要判断外部存储条件是否可用,然后进行存储</li><li>SP存储,底层是Xml实现的,以键值对形式存储内部的数据,适宜于轻量级的存储,存储的数据类型有,boolean,String,int</li><li>数据库存储,SQlite存储,轻量级的数据库,强大的增删改查功能</li><li>内容提供者,ContentProvider,将自己愿意暴露的一部分数据供外部使用操作</li><li>网络存储,等等</li></ul><h4 id="Sharepreference-线程安全问题？"><a href="#Sharepreference-线程安全问题？" class="headerlink" title="Sharepreference 线程安全问题？"></a>Sharepreference 线程安全问题？</h4><p>SharedPreferences不支持多进程，如果需要多进程通信，优先选择contentProvider。</p><p><strong>commit和apply方法的区别：</strong></p><p>commit和apply都是原子性操作。</p><p>commit是原子提交到数据库，所以从提交数据到存在Disk中都是同步过程，中间不可打断。</p><p>apply方法的原子操作是原子提交的内存中，而非数据库，所以在提交到内存中时不可打断，之后再异步提交数据到数据库中，因此也不会有相应的返回值。</p><p>所有commit提交是同步过程，效率会比apply异步提交的速度慢，但是apply没有返回值，永远无法知道存储是否失败。<br>在不关心提交结果是否成功的情况下，优先考虑apply方法。</p><h4 id="假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据"><a href="#假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据" class="headerlink" title="假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据?"></a>假设在多进程访问SharePreferences的情况下，该如何保证进程安全和共享数据?</h4><p>解决办法就是：将需要共享数据的字段提出来统一存储到一个文件中。但是多进程访问一个文件时，不能保证信息的安全性。（这里我也没想到解决办法，欢迎各位斧正）</p><h4 id="对象序列化："><a href="#对象序列化：" class="headerlink" title="对象序列化："></a>对象序列化：</h4><p><strong> 为什么要序列化？</strong></p><ul><li>永久性保存对象，保存对象的字节序列到本地文件中；</li><li>通过序列化对象在网络中传递对象；</li><li>通过序列化在进程间传递对象。</li></ul><p><strong>在Android中实现序列化有两个选择：</strong></p><p>一是实现Serializable接口（是JavaSE本身就支持的），一是实现Parcelable接口（是Android特有功能，效率比实现Serializable接口高效，可用于Intent数据传递，也可以用于进程间通信（IPC））。</p><p>实现Serializable接口非常简单，声明一下就可以了，而实现Parcelable接口稍微复杂一些，但效率更高，推荐用这种方法提高性能。</p><p>Google推荐Parcelable这种序列化，在这里，推荐一键生成序列化的插件:<a href="https://blog.csdn.net/shanshan_1117/article/details/80500512" target="_blank" rel="noopener">Android Parcelable code generators</a></p><h4 id="简述Android中的加固和使用平台"><a href="#简述Android中的加固和使用平台" class="headerlink" title="简述Android中的加固和使用平台?"></a>简述Android中的加固和使用平台?</h4><p>加固:防止代码反编译,提高代码安全性.</p><p>加固三方平台,梆梆安全,360加固,爱加密等</p><p>区别:梆梆安全,360加固看不到项目中的类,爱加密看的到Java类,但是看不到里面的方法实现体,效果比前面差一点点。</p><p>加固的底层原理:第三方加固的应用会生成一个Apk,然后把你的APK读取出来,封装到这个第三方应用的APK里面.</p><h4 id="如何对APK瘦身"><a href="#如何对APK瘦身" class="headerlink" title="如何对APK瘦身?"></a>如何对APK瘦身?</h4><ul><li>使用混淆,</li><li>开启shrinkResourse(shrink-收缩),会将没有用到的图片变成一个像素点</li><li>删除无用的语言资源(删除国际化文件)</li><li>对于非透明的大图,使用JPG(没有透明度信息),代替PNG格式</li><li>使用tinypng进行图片压缩</li><li>使用webp图片格式,进一步压缩图片资源</li><li>使用第三方包时把用到的代码加到项目中来,避免引用整一个第三方库</li></ul><h4 id="简述多渠道打包及原理和常用操作"><a href="#简述多渠道打包及原理和常用操作" class="headerlink" title="简述多渠道打包及原理和常用操作?"></a>简述多渠道打包及原理和常用操作?</h4><p>针对每一个渠道(应用市场)都生成一个带有渠道标识的apk文件.</p><p>原理:用户下载启动应用,获取渠道标识,和设备的唯一标识,并上传到服务器里面,服务器根据获取的记录,根据渠道号然后判断是否存在该服务器的表里面.(打标记,取标记,上传标记)</p><ul><li>友盟多渠道打包:在清单文件中定义一个占位符,在gradle脚本中替换占位符(会使用到Python)</li><li>美团打包,在meta-data中创建一个空的文件,以文件名标识渠道,做一个解压与压缩的操作,速度会比较快</li><li>新一代多渠道打包,将渠道标识添加到.apk文件的末尾,并不会对源文件损坏</li></ul><h4 id="OkHttp相关"><a href="#OkHttp相关" class="headerlink" title="OkHttp相关?"></a>OkHttp相关?</h4><p>OkHttp支持同步和异步数据请求，但异步请求是在子线程 (因为原生OkHttp的使用时回调方法是在子线程进行的，要刷新界面还需要用Handler作处理，可以使用第三方的okhttp-utils,Okgo等等)；</p><p>OkHttp里面封装了线程池、数据转换、GZIP压缩（减少流量的传输）、HTTP协议缓存等,<br>OKHttp优点—使用GZip压缩减少传输的数据量,缓存(减少重复请求);</p><p>失败重试(如果你的服务有多个IP地址,如果第一次连接失败,OKHttp将使用备用地址)</p><p>OKhttp是对http协议的封装,比较底层,因此拓展性强,便于封装;对于https协议的支持需要处理一下：<a href="https://www.jianshu.com/p/f2097616e65e" target="_blank" rel="noopener">戳这里查看详情</a></p><p>OKhttp基于NIO(JDK1.5,非阻塞式IO)效率更高</p><h4 id="ButterKnife相关"><a href="#ButterKnife相关" class="headerlink" title="ButterKnife相关?"></a>ButterKnife相关?</h4><p>一款快速高效的注入框架，节约开发时间减少代码量（依靠插件动态生成View,点击事件等等）</p><p>优点：<br>1.强大的View绑定和Click事件处理功能，简化代码，提升开发效率<br>2.方便的处理Adapter里的ViewHolder绑定问题<br>3.运行时不会影响APP效率，使用配置方便<br>4.代码清晰，可读性强</p><p>使用经验：<br>1.Activity ButterKnife.bind(this);必须在setContentView();之后，且父类bind绑定后，子类不需要再bind</p><p>2.Fragment ButterKnife.bind(this, mRootView);</p><p>3.属性布局不能用private or static 修饰，否则会报错，（注意权限）</p><p>4.setContentView()不能通过注解实现。（其他的有些注解框架可以）</p><p>原理：利用注解和反射去获取绑定ViewID.</p><h4 id="Rxjava概念-常用操作符及拓展"><a href="#Rxjava概念-常用操作符及拓展" class="headerlink" title="Rxjava概念,常用操作符及拓展?"></a>Rxjava概念,常用操作符及拓展?</h4><p>一款优雅的异步框架,代替之前的AsyncTask / Handler / XXX / … </p><p>其强大的操作符和链式写法,线程切换等有助于提高开发效率和快速定位Bug</p><p>与Retrofit搭配使用更是有意想不到的效果，</p><p>缺点：<br>1：操作符太多会增加学习成本时间<br>2：使用不好，容易导致内存泄露(解决方式，推荐Rxlifecycle结合Rxjava，规避内存泄漏风险)</p><h4 id="Android中那些场景是执行在主线程的"><a href="#Android中那些场景是执行在主线程的" class="headerlink" title="Android中那些场景是执行在主线程的?"></a>Android中那些场景是执行在主线程的?</h4><ul><li>Activity生命周期回调都是执行在主线程的.</li><li>Service默认是执行在主线程的.</li><li>BroadcastReceiver的onReceive回调是执行在主线程的.</li><li>没有使用子线程的looper的Handler的handleMessage, post(Runnable)是执行在主线程的.</li><li>AsyncTask的回调中除了doInBackground, 其他都是执行在主线程的.</li><li>View的post(Runnable)是执行在主线程的.</li></ul><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存:"></a>三级缓存:</h4><p>当我们第一次打开应用获取图片或其它资源时，首先到网络去下载，然后依次存入内存缓存，磁盘缓存，</p><p>当我们再一次需要用到刚才下载的这张图片时，就不需要再重复的到网络上去下载，直接可以从内存缓存和磁盘缓存中找，由于内存缓存速度较快，我们优先到内存缓存中寻找该图片，如果找到则运用，</p><p>如果没有找到（内存缓存大小有限），那么我们再到磁盘缓存中去找。</p><p>只要我们合理的去协调这三层缓存运用，便可以提升应用性能,给用户更好的体验</p><p>三级缓存指的是：内存缓存、本地缓存、网络缓存。其各自的特点是内存缓存速度快, 优先读取，本地缓存速度其次, 内存没有该资源信息就去读取本地内存，网络缓存速度较慢(比较对象是内存缓存和本地缓存),假设本地内存也没有,才请求网络获取。</p><h4 id="Android中的四大组件相关"><a href="#Android中的四大组件相关" class="headerlink" title="Android中的四大组件相关?"></a>Android中的四大组件相关?</h4><p><strong>Activity:</strong><br>Activity是一个应用程序组件，提供一个屏幕(狭义的理解就是当前APP的界面)，用户可以用来交互为了完成某项任务。(点击,登录,跳转页面)<br>Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件(设置布局文件)。<br>在一个android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。</p><p><strong>Activity四种启动模式?</strong></p><p>Activity的启动模式指,可以根据实际开发需求为Activity设置对应的启动模式，从而可以避免创建大量重复的Activity等问题。</p><ul><li>standard<br>standard为Activity的默认启动模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。(点back键会依照栈顺序依次退出)</li><li>singleTop<br>singleTop模式下,Activity可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。</li><li>singleTask<br>singleTask表示只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。</li><li>singleInstance<br>只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。</li></ul><p><strong>BraodcastReceiver:</strong></p><p>使用了设计模式中的观察者模式：基于消息的发布/订阅事件模型。<br>注册的方式分为两种：静态注册、动态注册</p><p><strong>ContentProvider:</strong><br>外界可以通过ContentResolver接口来访问ContentProvider(内容提供者)中的数据。Uri 通用资源标志符（Universal Resource Identifier）Uri代表要操作的数据，Android中可用的每种资源 - 图像、视频片段等都可以用Uri来表示。ContentProvider共享数据是通过定义一个对外开放的统一的接口来实现的。然而，应用程序并不直接调用这些方法，而是使用一个 ContentResolver 对象，调用它的方法作为替代。ContentResolver可以与任意内容提供者进行会话，与其合作来对所有相关交互通讯进行管理。当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver类来完成，要获取ContentResolver对象，可以使用Context提供的getContentResolver()方法。</p><p><strong>IntentService：</strong><br>IntentService是Service的子类，比普通的Service增加了额外的功能。IntentService会创建独立的worker线程来处理所有的Intent请求；会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程的问题；所有请求处理完成后，IntentService会自动停止，开发者无需手动调用stopSelf()方法停止Service；</p><h4 id="简述System-exit-0-、onDestory-、Activity-finish-三者的区别"><a href="#简述System-exit-0-、onDestory-、Activity-finish-三者的区别" class="headerlink" title="简述System.exit(0) 、onDestory()、Activity.finish()三者的区别"></a>简述System.exit(0) 、onDestory()、Activity.finish()三者的区别</h4><ul><li>System.exit(0) 是你正常结束程序,kill 掉当前进程,针对的是整个Application</li><li>onDestory()方法是Activity生命周期的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法.</li><li>Activity.finish()当你调用此方法的时候，系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory（）方法，<strong>也就是占用的资源没有被及时释放。</strong></li></ul><h4 id="图片优化，以及图片加载框架的使用，如Picasso、-Fresco、Glide等？"><a href="#图片优化，以及图片加载框架的使用，如Picasso、-Fresco、Glide等？" class="headerlink" title="图片优化，以及图片加载框架的使用，如Picasso、 Fresco、Glide等？"></a>图片优化，以及图片加载框架的使用，如Picasso、 Fresco、Glide等？</h4><ul><li>尽量使用小的图片,对图片进行压缩，bitmapfactory.options图片配置类，insimplesize进行缩放，设置图片的编码方式；对图片使用软引用，内存不够时即时释图片内存；对图片的复用，三级缓存的使用；<br><strong>及时回收不再使用的bitmap对象；</strong></li><li>Picasso,不支持gif，缓存的是Argb8888的原图，占用内存较大,图片的框架使用了OkHttp缓存机制,使用Http协议缓存,也是异步加载.</li><li>Fresco,框架是FaceBook公司推出的,适合批量加载图片,底层是通过三级缓存(2级内存,1级磁盘),加载成功后自动替换成目标图片; </li><li>glide,Google公司14年推出来的,可以加载GIF图,也可以根据指定图片清晰度,底层的原理:为Bitmap维护一个对象池,对象池的目的是通过减少对象的分配,以重用来提高性能.对象池也可以帮助提高滚动的性能。API简洁易调用</li></ul><h4 id="Handle相关"><a href="#Handle相关" class="headerlink" title="Handle相关:"></a>Handle相关:</h4><p>Handler 工作流程基本包括 Handler、Looper、Message、MessageQueue 四个部分。但我们在日常开发中，经常都只会用到 Handler 和 Message 两个类。Message 负责消息的搭载，里面有个target用于标记消息，obj用于存放内容，Handler 负责消息的分发和处理。</p><h4 id="一般在开发中是怎么使用-Handler-的？"><a href="#一般在开发中是怎么使用-Handler-的？" class="headerlink" title="一般在开发中是怎么使用 Handler 的？"></a>一般在开发中是怎么使用 Handler 的？</h4><p>官方不允许在子线程中更新 UI，所以我们经常会把需要更新 UI 的消息直接发给处理器 Handler，通过重写 Handler 的handleMessage()方法进行 UI 的相关操作。<br><strong>Handle使用中需要注意？</strong><br>Handler 如果设置为私有变量的话，Android Studio 会报警告，提示可能会造成内存泄漏，这种情况可以通过设置为静态内部类 + 弱引用，或者在onDestroy()方法中调用Handler.removeCallbacksAndMessages(null)即可避免<br>Handler 整体工作流程浅析分为以下四个步骤：<br><strong>异步通信准备 =&gt; 消息入队 =&gt; 消息循环 =&gt; 消息处理</strong></p><ul><li>A：异步通信准备</li></ul><p>I：假定是在主线程创建 Handler，则会直接在主线程中创建处理器对象Looper、消息队列对象MessageQueue和 Handler 对象。</p><p>需要注意的是，Looper和MessageQueue均是属于其创建线程的。</p><p>II：Looper对象的创建一般通过Looper.prepareMainLooper()和Looper.prepare()两个方法，而创建Looper对象的同时，将会自动创建MessageQueue。</p><p>III：创建好MessageQueue后，Looper将自动进入消息循环。此时，Handler自动绑定了主线程的Looper和MessageQueue。</p><ul><li>B：消息入队</li></ul><p>工作线程通过Handler发送消息Message到消息队列MessageQueue中，消息内容一般是 UI 操作。发送消息一般都是通过Handler.sendMessage(Message msg)和Handler.post(Runnabe r)两个方法来进行的。而入队一般是通过MessageQueue.enqueueeMessage(Message msg,long when)来处理。</p><ul><li><p>C：消息循环<br>主要分为「消息出队」和「消息分发」两个步骤，Looper会通过循环取出消息队列MessageQueue里面的消息Message，并分发到创建该消息的处理者Handler。如果消息循环过程中，消息队列MessageQueue为空队列的话，则线程阻塞。</p></li><li><p>D：消息处理<br>Handler接收到Looper发来的消息，开始进行处理。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓,温故而知新，可以为师矣！这段时间到处面试，结合工作和网上一些文章，深感学有涯而知无涯~&lt;br&gt;在这里梳理一下，供学习思考。本篇主要是 native开发涉及到的Java知识点和Android方面知识。&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
  </entry>
  
</feed>
